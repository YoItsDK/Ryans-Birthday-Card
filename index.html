<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=no"/>
<title>E-Birthday Card</title>
<style>
html,body{height:100%;margin:0;overflow:hidden;background:#0b0c10;touch-action:none;}
#canvas-container{width:100%;height:100%;position:absolute;top:0;left:0;display:block;}
#canvas-container canvas{width:100%!important;height:100%!important;display:block!important;position:absolute!important;top:0!important;left:0!important;max-width:100%!important;max-height:100%!important;}
#ui{position:fixed;top:12px;left:12px;z-index:10;display:flex;gap:8px;flex-wrap:wrap;}
button{padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.06);color:rgba(255,255,255,.9);touch-action:manipulation;}
button:hover{background:rgba(255,255,255,.12)}

/* Retro OS Button Styles */
#start-btn {
  transition: all 0.05s ease;
  user-select: none;
}

#start-btn:active {
  border-color: #808080 #dfdfdf #dfdfdf #808080 !important;
  box-shadow: inset 1px 1px 0 #808080 !important;
}

#start-btn:hover {
  filter: brightness(1.1);
}

/* Taskbar styles */
#status-time {
  font-weight: bold;
  letter-spacing: 1px;
}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/": "https://unpkg.com/three@0.160.0/"
  }
}
</script>

<!-- SSAO Post-processing Shader for AAA Quality -->
<script id="ssao-vertex" type="x-shader/x-vertex">
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>

<script id="ssao-fragment" type="x-shader/x-fragment">
uniform sampler2D tDiffuse;
uniform sampler2D tNormal;
uniform sampler2D tDepth;
uniform float radius;
uniform float bias;
uniform float intensity;
uniform vec2 resolution;
varying vec2 vUv;

const int SAMPLES = 16;
const float PI = 3.14159265;

float readDepth(vec2 coord) {
  float cameraFar = 1000.0;
  float cameraNear = 0.1;
  float z = texture2D(tDepth, coord).x;
  return (2.0 * cameraNear) / (cameraFar + cameraNear - z * (cameraFar - cameraNear));
}

vec3 getPosition(vec2 uv, float depth) {
  vec4 clipSpaceLocation = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
  vec4 homogenousLocation = vec4(1.0);
  vec3 worldSpaceLocation = homogenousLocation.xyz;
  return worldSpaceLocation;
}

void main() {
  float depth = readDepth(vUv);
  vec3 normal = normalize(texture2D(tNormal, vUv).rgb * 2.0 - 1.0);
  
  float ao = 0.0;
  for (int i = 0; i < SAMPLES; i++) {
    float angle = float(i) / float(SAMPLES) * PI * 2.0;
    float distance = radius * (float(i) + 1.0) / float(SAMPLES);
    
    vec2 sampleOffset = vec2(cos(angle), sin(angle)) * distance / resolution;
    vec2 sampleCoord = vUv + sampleOffset;
    
    float sampleDepth = readDepth(sampleCoord);
    float depthDifference = depth - sampleDepth;
    
    if (depthDifference > bias && depthDifference < radius) {
      ao += 1.0;
    }
  }
  
  ao /= float(SAMPLES);
  ao = 1.0 - ao * intensity;
  
  vec4 color = texture2D(tDiffuse, vUv);
  gl_FragColor = vec4(color.rgb * ao, color.a);
}
</script>

<!-- ============================================================================ -->
<!-- CUSTOM SHADER LIBRARY - Advanced Visual Effects & Performance Optimization  -->
<!-- ============================================================================ -->

<!-- PARALLAX MAPPING SHADER - Enhanced depth perception on surfaces -->
<script id="parallax-vertex" type="x-shader/x-vertex">
uniform float heightScale;
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vTangent;
varying vec3 vBitangent;
varying vec3 vViewDir;

void main() {
  vUv = uv;
  vNormal = normalize(normalMatrix * normal);
  vTangent = normalize(normalMatrix * vec3(1.0, 0.0, 0.0));
  vBitangent = normalize(cross(vNormal, vTangent));
  
  vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
  vViewDir = normalize(cameraPosition - worldPos);
  
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>

<script id="parallax-fragment" type="x-shader/x-fragment">
uniform sampler2D tDiffuse;
uniform sampler2D tHeightMap;
uniform sampler2D tNormalMap;
uniform float heightScale;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vTangent;
varying vec3 vBitangent;
varying vec3 vViewDir;

void main() {
  vec2 parallaxUv = vUv;
  vec4 diffuse = texture2D(tDiffuse, parallaxUv);
  gl_FragColor = diffuse;
}
</script>

<!-- RIM LIGHT SHADER - Cinematic edge highlighting -->
<script id="rimlight-vertex" type="x-shader/x-vertex">
varying vec3 vNormal;
varying vec3 vViewDir;

void main() {
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  vNormal = normalize(normalMatrix * normal);
  vViewDir = normalize((modelViewMatrix * vec4(position, 1.0)).xyz);
}
</script>

<script id="rimlight-fragment" type="x-shader/x-fragment">
uniform vec3 rimColor;
uniform float rimPower;
uniform sampler2D tDiffuse;

varying vec3 vNormal;
varying vec3 vViewDir;

void main() {
  float rim = 1.0 - dot(normalize(vNormal), normalize(-vViewDir));
  rim = smoothstep(0.0, 1.0, rim);
  rim = pow(rim, rimPower);
  
  gl_FragColor = vec4(rimColor, rim * 0.5);
}
</script>

<!-- SUBSURFACE SCATTERING SHADER - Organic material translucency -->
<script id="sss-vertex" type="x-shader/x-vertex">
varying vec3 vNormal;
varying vec3 vViewDir;
varying vec3 vLightDir;
varying vec2 vUv;

uniform vec3 lightPos;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  vNormal = normalize(normalMatrix * normal);
  
  vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
  vViewDir = normalize(cameraPosition - worldPos);
  vLightDir = normalize(lightPos - worldPos);
}
</script>

<script id="sss-fragment" type="x-shader/x-fragment">
uniform sampler2D tDiffuse;
uniform float thickness;
uniform vec3 scatterColor;

varying vec3 vNormal;
varying vec3 vViewDir;
varying vec3 vLightDir;
varying vec2 vUv;

void main() {
  vec4 diffuse = texture2D(tDiffuse, vUv);
  
  float backLight = max(0.0, -dot(vNormal, vLightDir));
  vec3 scattering = backLight * thickness * scatterColor;
  
  vec3 finalColor = diffuse.rgb + scattering;
  gl_FragColor = vec4(finalColor, diffuse.a);
}
</script>

<!-- FAST GEOMETRY SHADER - Optimized vertex rendering -->
<script id="fast-geom-vertex" type="x-shader/x-vertex">
varying vec3 vNormal;
varying vec3 vColor;

void main() {
  vNormal = normalize(normalMatrix * normal);
  vColor = color;
  
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>

<script id="fast-geom-fragment" type="x-shader/x-fragment">
varying vec3 vNormal;
varying vec3 vColor;

void main() {
  vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
  float diffuse = max(0.0, dot(vNormal, lightDir)) * 0.8 + 0.2;
  
  gl_FragColor = vec4(vColor * diffuse, 1.0);
}
</script>

<!-- Bloom Post-processing Shader for Cinematic Effect -->
<script id="bloom-vertex" type="x-shader/x-vertex">
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>

<script id="bloom-fragment" type="x-shader/x-fragment">
uniform sampler2D tDiffuse;
uniform float threshold;
uniform float strength;
varying vec2 vUv;

void main() {
  vec4 color = texture2D(tDiffuse, vUv);
  float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
  
  if (luminance > threshold) {
    gl_FragColor = vec4(color.rgb * strength, color.a);
  } else {
    gl_FragColor = vec4(vec3(0.0), color.a);
  }
}
</script>
</head>
<body>
<!-- Main Menu Screen -->
<div id="canvas-container" style="width: 100%; height: 100%; position: absolute; top: 0; left: 0;"></div>

<!-- Birthday Message Screen Overlay -->
<div id="birthday-message" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0f1625 100%); display: flex; align-items: center; justify-content: center; z-index: 1000; cursor: pointer;">
  <div style="text-align: center; animation: fadeInScale 0.6s ease-out;">
    <h1 style="font-size: 48px; color: #fff; margin: 0; font-weight: 300; letter-spacing: 2px; margin-bottom: 20px;">üéâ</h1>
    <h2 style="font-size: 42px; color: #fff; margin: 0 0 15px 0; font-weight: 300; text-shadow: 0 2px 10px rgba(100,200,255,0.3);">You're Viewing a Birthday Card</h2>
    <p style="font-size: 18px; color: #aaa; margin: 0 0 30px 0; letter-spacing: 1px;">Click anywhere to continue</p>
    <div style="font-size: 28px; animation: bounce 1.5s infinite;">‚Üì</div>
  </div>
</div>

<style>
@keyframes fadeInScale {
  from {
    opacity: 0;
    transform: scale(0.8);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes bounce {
  0%, 100% {
    transform: translateY(0);
    opacity: 1;
  }
  50% {
    transform: translateY(10px);
    opacity: 0.7;
  }
}
</style>

<div id="ui">
  <button id="reset">Reset view</button>
  <button id="auto">Auto-rotate: Off</button>
  <button id="fullscreen" title="Press F to toggle fullscreen">Fullscreen</button>
  <button id="download" title="Download as HTML file">Download Card</button>
  <div id="status" style="color: white; font-size: 14px; margin-left: 20px;">Loading...</div>
  <div id="perf-monitor" style="color: #4eff7f; font-size: 12px; margin-left: 20px; display: none;">FPS: <span id="fps">60</span> | Memory: <span id="memory">0</span>MB</div>
</div>
<div id="bones-panel" style="position: fixed; top: 60px; left: 12px; background: rgba(0,0,0,0.95); display: none; flex-direction: column; font-size: 12px; border: 2px solid rgba(100,150,255,0.6); border-radius: 6px; width: 320px; height: 600px; box-shadow: 0 0 20px rgba(100,150,255,0.2); z-index: 100; user-select: none; color: white; font-family: 'Courier New', monospace;">
  <!-- Terminal Title Bar -->
  <div id="bones-title" style="background: linear-gradient(90deg, rgba(100,150,255,0.4), rgba(100,150,255,0.1)); padding: 8px 12px; border-bottom: 1px solid rgba(100,150,255,0.4); display: flex; justify-content: space-between; align-items: center; cursor: move; font-weight: bold; color: rgba(100,255,255,0.9); flex-shrink: 0; user-select: none;">
    <span style="display: flex; align-items: center; gap: 6px;">
      <span style="font-size: 10px;">‚óÜ</span> ANIMATION_CTRL.exe
    </span>
    <button id="close-bones-panel" style="background: rgba(200,100,100,0.6); border: 1px solid rgba(200,100,100,0.8); color: white; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; font-weight: bold;">‚úï</button>
  </div>
  
  <!-- Panel Content -->
  <div style="padding: 12px; overflow-y: auto; flex: 1; min-height: 0;">
    <div style="margin-bottom: 10px; color: rgba(100,255,255,0.8); font-size: 11px;">
      &gt; Select Animation
    </div>
    
    <div id="anim-selector" style="margin-bottom: 10px;">
      <select id="animation-dropdown" style="width: 100%; padding: 6px; background: rgba(100,150,255,0.15); color: rgba(100,255,255,0.9); border: 1px solid rgba(100,150,255,0.6); border-radius: 4px; font-family: 'Courier New', monospace; font-size: 11px; cursor: pointer;">
        <option value="">Select Animation...</option>
      </select>
    </div>
    
    <div style="display: flex; gap: 4px; margin-bottom: 10px;">
      <button id="anim-play" style="flex: 1; padding: 6px; background: rgba(100,200,100,0.3); border: 1px solid rgba(100,200,100,0.6); color: rgba(100,255,100,0.9); border-radius: 3px; cursor: pointer; font-weight: bold; font-family: 'Courier New', monospace; font-size: 11px;">‚ñ∂ PLAY</button>
      <button id="anim-pause" style="flex: 1; padding: 6px; background: rgba(200,150,100,0.3); border: 1px solid rgba(200,150,100,0.6); color: rgba(255,200,100,0.9); border-radius: 3px; cursor: pointer; font-weight: bold; font-family: 'Courier New', monospace; font-size: 11px;">‚è∏ PAUSE</button>
      <button id="anim-stop" style="flex: 1; padding: 6px; background: rgba(200,100,100,0.3); border: 1px solid rgba(200,100,100,0.6); color: rgba(255,100,100,0.9); border-radius: 3px; cursor: pointer; font-weight: bold; font-family: 'Courier New', monospace; font-size: 11px;">‚ñ† STOP</button>
    </div>
    
    <div style="margin-bottom: 10px;">
      <label style="display: block; margin-bottom: 4px; color: rgba(100,255,255,0.8); font-size: 10px;">TIMELINE</label>
      <input id="anim-timeline" type="range" min="0" max="100" value="0" style="width: 100%; cursor: pointer; accent-color: rgba(100,255,255,0.8);">
      <div style="font-size: 10px; margin-top: 4px; color: rgba(100,255,255,0.7);">
        <span id="anim-time">0.00</span>s / <span id="anim-duration">0.00</span>s
      </div>
    </div>
    
    <div style="margin-bottom: 10px;">
      <label style="display: block; margin-bottom: 4px; color: rgba(100,255,255,0.8); font-size: 10px;">SPEED MULTIPLIER</label>
      <input id="anim-speed" type="range" min="0.1" max="2" step="0.1" value="1" style="width: 100%; cursor: pointer; accent-color: rgba(100,255,255,0.8);">
      <div style="font-size: 10px; color: rgba(100,255,255,0.7);">√ó<span id="speed-value">1.0</span></div>
    </div>
    
    <div style="margin-bottom: 10px; border-top: 1px solid rgba(100,150,255,0.3); padding-top: 10px;">
      <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; margin-bottom: 6px;">
        <input id="sequence-mode" type="checkbox" style="cursor: pointer; accent-color: rgba(100,255,255,0.8);" disabled>
        <span id="sequence-label" style="color: rgba(100,255,255,0.7); font-size: 10px;">CHAIN_ANIM</span>
      </label>
      <div id="sequence-info" style="color: rgba(100,255,255,0.5); margin-top: 4px; display: none; font-size: 9px; background: rgba(100,150,255,0.1); padding: 4px; border-radius: 2px;">
        <span id="sequence-text">Animation chaining enabled</span>
      </div>
    </div>
    
    <div style="border-top: 1px solid rgba(100,150,255,0.3); padding-top: 10px;">
      <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; margin-bottom: 6px;">
        <input id="anim-loop" type="checkbox" style="cursor: pointer; accent-color: rgba(100,255,255,0.8);">
        <span style="color: rgba(100,255,255,0.7); font-size: 10px;">LOOP_MODE</span>
      </label>
      <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
        <input id="anim-autoplay" type="checkbox" style="cursor: pointer; accent-color: rgba(100,255,255,0.8);">
        <span style="color: rgba(100,255,255,0.7); font-size: 10px;">AUTO_PLAY</span>
      </label>
    </div>
    
    <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(100,150,255,0.3);">
      <div id="anim-info" style="font-size: 9px; color: rgba(100,255,255,0.5); font-family: 'Courier New', monospace; background: rgba(100,150,255,0.05); padding: 6px; border-radius: 2px; border-left: 2px solid rgba(100,255,255,0.4);">
        No animation selected
      </div>
    </div>
  </div>
</div>

<!-- Debug Menu -->
<div id="debug-menu" style="position: fixed; bottom: 12px; right: 12px; background: rgba(0,0,0,0.95); padding: 16px; border-radius: 8px; color: #00ff00; font-family: monospace; font-size: 11px; display: none; max-width: 500px; max-height: 80vh; overflow-y: auto; border: 2px solid #00ff00; box-shadow: 0 0 10px rgba(0,255,0,0.3);">
  <div style="font-weight: bold; margin-bottom: 12px; border-bottom: 1px solid #00ff00; padding-bottom: 8px;">üîß DEV CONSOLE (Ctrl+Shift+D)</div>
  
  <!-- Stats Section -->
  <div style="margin-bottom: 12px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê STATS ‚ïê</div>
    <div style="margin-bottom: 3px;"><strong>FPS:</strong> <span id="debug-fps">60</span> | <strong>Memory:</strong> <span id="debug-memory">0</span>MB</div>
    <div style="margin-bottom: 3px;"><strong>Quality:</strong> <span id="debug-quality">high</span> | <strong>Shadows:</strong> <span id="debug-shadows">enabled</span></div>
    <div style="margin-bottom: 3px;"><strong>Camera:</strong> <span id="debug-camera">0,0,0</span></div>
    <div style="margin-bottom: 3px;"><strong>Start Pos:</strong> <span id="debug-camera-start">0,0,0</span></div>
    <div style="margin-bottom: 6px;">
      <button id="debug-copy-camera" style="padding: 4px 8px; background: #00ff00; color: #000; border: none; border-radius: 3px; cursor: pointer; font-size: 10px; font-family: monospace; font-weight: bold; margin-right: 4px;">Copy Position</button>
      <button id="debug-save-camera" style="padding: 4px 8px; background: #00aaff; color: #000; border: none; border-radius: 3px; cursor: pointer; font-size: 10px; font-family: monospace; font-weight: bold;">Save as Default</button>
    </div>
    <div id="camera-state-display" style="font-size: 9px; color: #00ff00; margin-bottom: 6px; padding: 4px; background: rgba(0,255,0,0.05); border-radius: 2px; display: none;">
      <div>üìç Position: <span id="camera-pos-full">0,0,0</span></div>
      <div>üëÅÔ∏è Target: <span id="camera-target-full">0,0,0</span></div>
      <div>üîç Distance: <span id="camera-distance">0.00</span> | üéØ Zoom: <span id="camera-zoom">1.0</span></div>
    </div>
    <div style="margin-bottom: 3px;"><strong>Start Pos:</strong> <span id="debug-camera-start">0,0,0</span></div>
    <div style="margin-bottom: 3px;"><strong>Scene Objects:</strong> <span id="debug-objects">0</span> | <strong>Meshes:</strong> <span id="debug-meshes">0</span></div>
    <div style="margin-bottom: 3px;"><strong>Model Loaded:</strong> <span id="debug-loaded">false</span></div>
  </div>
  
  <!-- Hover Info Section -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê HOVER INFO ‚ïê</div>
    <div id="hover-type" style="color: #00ff00; margin-bottom: 2px;">Type: <span style="color: #88ff00;">‚Äî</span></div>
    <div id="hover-name" style="color: #00ff00; margin-bottom: 2px;">Name: <span style="color: #88ff00;">‚Äî</span></div>
    <div id="hover-position" style="color: #00ff00; margin-bottom: 6px; font-size: 9px;">Pos: <span style="color: #88ff00;">‚Äî</span></div>
  </div>
  
  <!-- Freeplay Bone Selection -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê FREEPLAY BONE ‚ïê</div>
    <select id="freeplay-bone-select" style="width: 100%; padding: 4px; background: rgba(0,255,0,0.1); color: #00ff00; border: 1px solid #00ff00; border-radius: 3px; font-family: monospace; font-size: 10px; cursor: pointer;">
      <option value="">None (Disabled)</option>
    </select>
    <div id="freeplay-bone-status" style="color: #00aa00; margin-top: 4px; font-size: 9px;">Status: Disabled</div>
  </div>
  
  <!-- Freeplay Mode Indicator -->
  <div id="freeplay-mode-indicator" style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px; display: none;">
    <div style="background: rgba(0,255,255,0.1); border: 2px solid #00ffff; border-radius: 4px; padding: 8px; text-align: center;">
      <div style="color: #00ffff; font-weight: bold; font-size: 12px; text-shadow: 0 0 10px rgba(0,255,255,0.5);">üéÆ FREEPLAY MODE ACTIVE</div>
      <div style="color: #00aaaa; font-size: 10px; margin-top: 4px;">Drag to move freely with physics</div>
    </div>
  </div>
  
  <!-- Bone Visibility Control -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <label style="display: flex; gap: 6px; cursor: pointer;">
      <input type="checkbox" id="dev-show-bones" style="cursor: pointer;"> SHOW_BONES
    </label>
    <div style="color: #00aa00; margin-top: 4px; font-size: 9px;">‚úì Bones visible on hover</div>
  </div>
  
  <!-- Animation Control Menu Toggle -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <label style="display: flex; gap: 6px; cursor: pointer;">
      <input type="checkbox" id="dev-show-animation-ctrl" style="cursor: pointer;"> ANIMATION_CTRL
    </label>
    <div style="color: #00aa00; margin-top: 4px; font-size: 9px;">‚úì Show animation control panel</div>
  </div>
  
  <!-- Rendering Options -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê RENDERING ‚ïê</div>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-wireframe" style="cursor: pointer;"> WIREFRAME
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-borders" checked style="cursor: pointer;"> SHOW_BORDERS
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-grid" style="cursor: pointer;"> GRID_HELPER
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-axes" style="cursor: pointer;"> AXES_HELPER
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-bbox" style="cursor: pointer;"> BOUNDING_BOX
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-collision-viz" style="cursor: pointer;"> COLLISION_VIZ (Ctrl+Shift+C)
    </label>
    <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #666;">
      <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer; font-size: 9px;">
        VIZ MODE:
        <select id="dev-viz-mode" style="cursor: pointer; background: #1a1a1a; color: #00ff00; border: 1px solid #00ff00; padding: 2px; font-size: 9px; font-family: monospace;">
          <option value="normal">NORMAL</option>
          <option value="depth">DEPTH</option>
          <option value="normals">NORMALS</option>
          <option value="flat">FLAT_SHADING</option>
          <option value="lighting">LIGHTING_ONLY</option>
          <option value="ao">AMBIENT_OCC</option>
        </select>
      </label>
    </div>
  </div>
  
  <!-- Lighting Options -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê LIGHTING ‚ïê</div>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-shadows" checked style="cursor: pointer;"> SHADOWS
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-lighthelpers" style="cursor: pointer;"> LIGHT_HELPERS
    </label>
    <div style="margin-bottom: 4px;">
      <label style="display: flex; gap: 6px; cursor: pointer;">
        <input type="checkbox" id="dev-ambient" checked style="cursor: pointer;"> AMBIENT (
        <input type="range" id="dev-ambient-intensity" min="0" max="2" step="0.1" value="0.5" style="width: 60px; cursor: pointer;">
        <span id="dev-ambient-val">0.5</span>)
      </label>
    </div>
  </div>
  
  <!-- Physics/Collision -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê COLLISION ‚ïê</div>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-collision" checked style="cursor: pointer;"> CAMERA_COLLISION
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-raycasts" style="cursor: pointer;"> SHOW_RAYCASTS
    </label>
    
    <!-- Collision Radius Slider -->
    <div style="margin-top: 8px; padding: 6px; background: rgba(0,255,0,0.05); border-radius: 3px;">
      <div style="font-size: 9px; color: #00ff00; margin-bottom: 4px;">
        Radius: <span id="collision-radius-value">0.08</span> units
      </div>
      <input type="range" id="collision-radius-slider" min="0.01" max="0.3" step="0.01" value="0.08" 
             style="width: 100%; height: 6px; cursor: pointer;">
    </div>
    
    <!-- Smooth Factor Slider -->
    <div style="margin-top: 6px; padding: 6px; background: rgba(0,255,0,0.05); border-radius: 3px;">
      <div style="font-size: 9px; color: #00ff00; margin-bottom: 4px;">
        Smoothing: <span id="collision-smooth-value">0.15</span>
      </div>
      <input type="range" id="collision-smooth-slider" min="0.01" max="0.5" step="0.01" value="0.15" 
             style="width: 100%; height: 6px; cursor: pointer;">
    </div>
  </div>
  
  <!-- PERFORMANCE & OPTIMIZATION -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê PERFORMANCE ‚ïê</div>
    
    <!-- Quality Switcher -->
    <div style="margin-bottom: 8px; padding: 6px; background: rgba(255,255,0,0.1); border-radius: 3px; border: 1px solid #ffff00;">
      <div style="font-size: 9px; color: #ffff00; margin-bottom: 4px; font-weight: bold;">QUALITY LEVEL</div>
      <div style="display: flex; gap: 4px;">
        <button id="quality-low" style="flex: 1; padding: 4px; background: #333; color: #00ff00; border: 1px solid #00ff00; cursor: pointer; font-size: 9px; border-radius: 2px;">LOW</button>
        <button id="quality-med" style="flex: 1; padding: 4px; background: #333; color: #00ff00; border: 1px solid #00ff00; cursor: pointer; font-size: 9px; border-radius: 2px;">MED</button>
        <button id="quality-high" style="flex: 1; padding: 4px; background: #333; color: #00ff00; border: 1px solid #00ff00; cursor: pointer; font-size: 9px; border-radius: 2px;">HIGH</button>
      </div>
    </div>
    
    <!-- Real-time Performance Stats -->
    <div style="margin-bottom: 6px; padding: 6px; background: rgba(0,255,0,0.05); border-left: 2px solid #00ff00; border-radius: 2px;">
      <div style="font-size: 9px; color: #00ff00;">
        <div>üî∏ FPS: <span id="perf-fps">60</span> | Avg: <span id="perf-avg-fps">60</span></div>
        <div>üî∏ Frame Time: <span id="perf-frametime">16.67</span>ms</div>
        <div>üî∏ Draw Calls: <span id="perf-drawcalls">0</span> | Meshes: <span id="perf-meshes">0</span></div>
        <div>üî∏ Triangles: <span id="perf-triangles">0</span>K</div>
        <div>üî∏ Textures: <span id="perf-textures">0</span> | Shaders: <span id="perf-shader-cache">0</span></div>
        <div>üî∏ Memory: <span id="perf-memory">0</span>MB | GPU Mem: <span id="perf-gpu-mem">0</span>MB</div>
      </div>
    </div>
    
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="perf-frustum-cull" checked style="cursor: pointer;"> FRUSTUM_CULLING
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="perf-texture-opt" checked style="cursor: pointer;"> TEXTURE_OPT
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="perf-mesh-merge" style="cursor: pointer;"> MERGE_MESHES
    </label>
  </div>
  
  <!-- SHADER EFFECTS -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê SHADER EFFECTS ‚ïê</div>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="shader-rimlight" style="cursor: pointer;"> RIM_LIGHT
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="shader-sss" style="cursor: pointer;"> SUBSURFACE_SCATTER
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="shader-parallax" style="cursor: pointer;"> PARALLAX_MAP
    </label>
    <div style="font-size: 9px; color: #00aa00; margin-top: 4px;">Available shaders: 4</div>
  </div>
  
  <!-- Camera Controls -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê CAMERA ‚ïê</div>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-damping" checked style="cursor: pointer;"> DAMPING
    </label>
    <div style="margin-bottom: 4px;">
      <button id="dev-reset-camera" style="padding: 4px 8px; background: rgba(0,255,0,0.2); border: 1px solid #00ff00; color: #00ff00; border-radius: 2px; cursor: pointer; width: 100%; margin-bottom: 4px;">RESET_CAMERA</button>
      <button id="dev-set-starting-camera" style="padding: 4px 8px; background: rgba(0,255,0,0.3); border: 1px solid #00ff00; color: #00ff00; border-radius: 2px; cursor: pointer; width: 100%; font-weight: bold;">üíæ SET STARTING CAMERA</button>
    </div>
    <div style="font-size: 9px; color: #00aa00;">Speed: <span id="dev-camera-speed">0</span> units/s</div>
  </div>

  <!-- Animation Camera Lock Offset -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê ANIMATION CAMERA LOCK ‚ïê</div>
    
    <button id="capture-cam-position" style="width: 100%; padding: 4px 8px; background: rgba(0,255,0,0.3); border: 1px solid #00ff00; color: #00ff00; border-radius: 2px; cursor: pointer; font-size: 9px; margin-bottom: 4px; font-weight: bold;">üì∑ CAPTURE CURRENT POSITION</button>
    <button id="set-both-cameras" style="width: 100%; padding: 4px 8px; background: rgba(100,255,100,0.4); border: 2px solid #00ff00; color: #00ff00; border-radius: 2px; cursor: pointer; font-size: 9px; margin-bottom: 6px; font-weight: bold;">üé¨ SET BOTH CAMERAS (START + ANIMATION)</button>
    
    <div style="margin-bottom: 6px;">
      <label style="display: block; color: #00aa00; font-size: 9px; margin-bottom: 2px;">X (LEFT/RIGHT): <span id="cam-x-value">12.56</span></label>
      <input id="cam-offset-x" type="range" min="-20" max="20" step="0.01" value="12.56" style="width: 100%; cursor: pointer; accent-color: #00ff00; height: 4px;">
    </div>
    
    <div style="margin-bottom: 6px;">
      <label style="display: block; color: #00aa00; font-size: 9px; margin-bottom: 2px;">Y (UP/DOWN): <span id="cam-y-value">10.36</span></label>
      <input id="cam-offset-y" type="range" min="-20" max="20" step="0.01" value="10.36" style="width: 100%; cursor: pointer; accent-color: #00ff00; height: 4px;">
    </div>
    
    <div style="margin-bottom: 6px;">
      <label style="display: block; color: #00aa00; font-size: 9px; margin-bottom: 2px;">Z (FORWARD/BACK): <span id="cam-z-value">-8.10</span></label>
      <input id="cam-offset-z" type="range" min="-20" max="20" step="0.01" value="-8.10" style="width: 100%; cursor: pointer; accent-color: #00ff00; height: 4px;">
    </div>

    <button id="reset-cam-offset" style="width: 100%; padding: 4px 8px; background: rgba(0,255,0,0.2); border: 1px solid #00ff00; color: #00ff00; border-radius: 2px; cursor: pointer; font-size: 9px;">RESET</button>
  </div>
  
  <!-- Rendering Modes -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê RENDERING MODES ‚ïê</div>
    <div style="display: flex; gap: 4px; margin-bottom: 6px;">
      <button id="dev-mode-standard" style="flex: 1; padding: 4px 6px; background: rgba(0,255,0,0.3); border: 1px solid #00ff00; color: #00ff00; border-radius: 2px; cursor: pointer; font-size: 9px;">STANDARD</button>
      <button id="dev-mode-eevee" style="flex: 1; padding: 4px 6px; background: rgba(0,255,0,0.1); border: 1px solid #666; color: #00aa00; border-radius: 2px; cursor: pointer; font-size: 9px;">EEVEE</button>
      <button id="dev-mode-cycles" style="flex: 1; padding: 4px 6px; background: rgba(0,255,0,0.1); border: 1px solid #666; color: #00aa00; border-radius: 2px; cursor: pointer; font-size: 9px;">CYCLES</button>
    </div>
    <div style="font-size: 9px; color: #00aa00;">Active: <span id="dev-mode-active">STANDARD</span></div>
  </div>
  
  <!-- Visual Filters -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê VISUAL FILTERS ‚ïê</div>
    <div style="display: flex; gap: 4px; margin-bottom: 6px;">
      <button id="filter-ps2" style="flex: 1; padding: 4px 6px; background: rgba(0,255,0,0.1); border: 1px solid #00ff00; color: #00aa00; border-radius: 2px; cursor: pointer; font-size: 9px;">PS2 GRAPHICS</button>
      <button id="filter-vhs" style="flex: 1; padding: 4px 6px; background: rgba(0,255,0,0.1); border: 1px solid #00ff00; color: #00aa00; border-radius: 2px; cursor: pointer; font-size: 9px;">VHS EFFECT</button>
      <button id="filter-none" style="flex: 1; padding: 4px 6px; background: rgba(0,255,0,0.3); border: 1px solid #00ff00; color: #00ff00; border-radius: 2px; cursor: pointer; font-size: 9px; font-weight: bold;">NORMAL</button>
    </div>
    <div style="font-size: 9px; color: #00aa00;">Active: <span id="filter-active">NORMAL</span></div>
  </div>
  
  <!-- Performance -->
  <div style="margin-bottom: 12px; border-top: 1px solid #00ff00; padding-top: 8px;">
    <div style="color: #ffff00; font-weight: bold; margin-bottom: 6px; font-size: 10px;">‚ïê PERFORMANCE ‚ïê</div>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-frustum" checked style="cursor: pointer;"> FRUSTUM_CULL
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-bone-cull" checked style="cursor: pointer;"> BONE_CULL
    </label>
    <label style="display: flex; gap: 6px; margin-bottom: 4px; cursor: pointer;">
      <input type="checkbox" id="dev-pixelratio" style="cursor: pointer;"> REDUCE_PIXELRATIO
    </label>
    <div style="font-size: 9px; color: #00aa00;">Drawcalls: <span id="dev-drawcalls">0</span> | Triangles: <span id="dev-triangles">0</span> | Visible: <span id="dev-visible-objects">0</span></div>
  </div>
  
  <!-- Info Section -->
  <div style="border-top: 1px solid #00ff00; padding-top: 8px; color: #00aa00; font-size: 10px;">
    <div><strong>Controls:</strong></div>
    <div>‚Ä¢ L-Click: Rotate | R-Click: Pan | Scroll: Zoom</div>
    <div>‚Ä¢ F: Fullscreen | H: Toggle UI | A: Animations</div>
    <div>‚Ä¢ P: Perf | Ctrl+Shift+D: Dev Console</div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

const statusEl = document.getElementById("status");

// Catch any errors
window.addEventListener('error', (e) => {
  console.error("Global error:", e);
  statusEl.textContent = "ERROR: " + e.message;
});

try {
  const MODEL_URL = "./Birthday-Card-Scene.glb";
  
  // Performance monitoring
  let frameCount = 0;
  let lastTime = performance.now();
  let fps = 60;
  
  // Quality settings
  let qualityLevel = 'medium'; // 'low', 'medium', 'high' - default MEDIUM for 60 FPS target
  let shadowResolution = 1024;
  let enableShadows = true;
  let pixelRatio = Math.min(devicePixelRatio, 1.5); // Cap pixel ratio for performance
  let maxLights = 2;
  
  // Load saved quality preference
  const savedQuality = localStorage.getItem('birthdayCardQuality');
  if (savedQuality && ['low', 'medium', 'high'].includes(savedQuality)) {
    qualityLevel = savedQuality;
  }
  
  // Save quality preference
  function setQualityLevel(level) {
    qualityLevel = level;
    localStorage.setItem('birthdayCardQuality', level);
  }
  
  // Detect device capability
  function detectDeviceCapability() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
    const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const maxVary = gl.getParameter(gl.MAX_VARYING_VECTORS);
    
    // Low-end device detection
    const isLowEnd = maxTexSize < 2048 || maxVary < 8;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (isLowEnd || (isMobile && !navigator.hardwareConcurrency)) {
      qualityLevel = 'low';
      shadowResolution = 512;
      pixelRatio = 1;
      enableShadows = false;
    } else if (isMobile) {
      qualityLevel = 'medium';
      shadowResolution = 1024;
      pixelRatio = Math.min(devicePixelRatio, 1.5);
    }
    
    console.log(`Device capability: ${qualityLevel} | Mobile: ${isMobile} | MaxTexSize: ${maxTexSize}`);
  }
  
  detectDeviceCapability();
  
  console.log("Starting Three.js scene setup...");
  statusEl.textContent = "Initializing Three.js...";
  
  // ============================================================================
  // ADVANCED SHADER LIBRARY - Reusable custom shaders for effects
  // ============================================================================
  
  window.ShaderLibrary = {
    // Rim light shader for cinematic edge effects
    rimLight: {
      uniforms: {
        rimColor: { value: new THREE.Color(0xff9900) },
        rimPower: { value: 5.0 },
        rimStrength: { value: 0.5 }
      },
      vertexShader: document.getElementById('rimlight-vertex').textContent,
      fragmentShader: document.getElementById('rimlight-fragment').textContent
    },
    
    // Subsurface scattering for translucent materials
    subsurfaceScatter: {
      uniforms: {
        thickness: { value: 0.5 },
        scatterColor: { value: new THREE.Color(0xff6633) },
        lightPos: { value: new THREE.Vector3(5, 5, 5) }
      },
      vertexShader: document.getElementById('sss-vertex').textContent,
      fragmentShader: document.getElementById('sss-fragment').textContent
    },
    
    // Parallax mapping for enhanced surface detail
    parallax: {
      uniforms: {
        heightScale: { value: 0.1 }
      },
      vertexShader: document.getElementById('parallax-vertex').textContent,
      fragmentShader: document.getElementById('parallax-fragment').textContent
    },
    
    // Fast geometry shader for optimization
    fastGeometry: {
      uniforms: {},
      vertexShader: document.getElementById('fast-geom-vertex').textContent,
      fragmentShader: document.getElementById('fast-geom-fragment').textContent
    }
  };
  
  // Shader compiler and caching
  window.ShaderCache = {};
  window.compileShader = (name, vertexShader, fragmentShader) => {
    const key = `${name}_${vertexShader.slice(0,50)}`;
    if (!window.ShaderCache[key]) {
      window.ShaderCache[key] = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        side: THREE.DoubleSide,
        wireframe: false
      });
    }
    return window.ShaderCache[key];
  };
  
  console.log("‚úì Shader Library initialized with 4 custom shaders");
  
  // ============================================================================
  // PERFORMANCE OPTIMIZATION SYSTEM
  // ============================================================================
  
  window.PerformanceMonitor = {
    drawCalls: 0,
    memory: 0,
    meshCount: 0,
    textureCount: 0,
    lastFrameTime: 0,
    fps: 60,
    targetFPS: 60,
    
    update: function() {
      if (performance.memory) {
        this.memory = (performance.memory.usedJSHeapSize / 1048576).toFixed(0);
      }
      
      // Count scene objects
      let meshCount = 0, textureCount = 0;
      scene.traverse(obj => {
        if (obj.isMesh) meshCount++;
        if (obj.material) {
          if (obj.material.map) textureCount++;
          if (obj.material.normalMap) textureCount++;
          if (obj.material.roughnessMap) textureCount++;
        }
      });
      this.meshCount = meshCount;
      this.textureCount = textureCount;
    },
    
    log: function() {
      console.log('‚ïê‚ïê‚ïê PERFORMANCE STATS ‚ïê‚ïê‚ïê');
      console.log(`Memory: ${this.memory}MB`);
      console.log(`Meshes: ${this.meshCount}`);
      console.log(`Textures: ${this.textureCount}`);
      console.log(`FPS: ${this.fps}`);
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    }
  };
  
  // Geometry optimization utilities
  window.GeometryOptimizer = {
    mergedMeshes: 0,
    
    // Merge static meshes to reduce draw calls
    mergeMeshes: function(meshArray) {
      if (meshArray.length === 0) return null;
      
      const geometries = [];
      const materials = [];
      
      meshArray.forEach(mesh => {
        if (mesh.isMesh) {
          geometries.push(mesh.geometry);
          materials.push(mesh.material);
        }
      });
      
      // Create merged geometry
      const mergedGeometry = new THREE.BufferGeometry();
      let offset = 0;
      
      geometries.forEach((geom, idx) => {
        const clone = geom.clone();
        clone.translate(offset, 0, 0);
        offset += 10;
        mergedGeometry.merge(clone);
      });
      
      this.mergedMeshes++;
      console.log(`‚úì Merged ${meshArray.length} meshes into 1`);
      return mergedGeometry;
    },
    
    // Create Level-of-Detail versions
    createLOD: function(mesh, levels = 3) {
      const lod = new THREE.LOD();
      lod.addLevel(mesh, 0);
      
      let geometry = mesh.geometry;
      for (let i = 1; i < levels; i++) {
        const simplifiedGeometry = geometry.clone();
        // In production, use geometry simplification library
        lod.addLevel(new THREE.Mesh(simplifiedGeometry, mesh.material), i * 50);
      }
      
      return lod;
    }
  };
  
  // Texture optimization
  window.TextureOptimizer = {
    optimizeTexture: function(texture, maxSize = 2048) {
      if (!texture) return null;
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Resize if needed
      if (texture.image.width > maxSize || texture.image.height > maxSize) {
        const scale = Math.min(maxSize / texture.image.width, maxSize / texture.image.height);
        canvas.width = texture.image.width * scale;
        canvas.height = texture.image.height * scale;
        ctx.drawImage(texture.image, 0, 0, canvas.width, canvas.height);
        
        texture.source.data = canvas;
        console.log(`‚úì Optimized texture to ${canvas.width}x${canvas.height}`);
      }
      
      // Set optimal filters
      texture.magFilter = THREE.LinearFilter;
      texture.minFilter = THREE.LinearMipmapLinearFilter;
      texture.anisotropy = renderer.capabilities.maxAnisotropy / 2;
      
      return texture;
    }
  };
  
  console.log("‚úì Performance Optimization System ready");
  
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0c10);
  console.log("Scene created");
  
  const camera = new THREE.PerspectiveCamera(39, innerWidth/innerHeight, 0.1, 1000);
  // Set default camera angle from current viewing position
  // Load full view state (position + target angle) or fall back to position only
  const savedStartingCam = localStorage.getItem('startingCameraPos');
  window.savedViewState = localStorage.getItem('cameraViewState');
  
  if (window.savedViewState) {
    const viewState = JSON.parse(window.savedViewState);
    camera.position.set(viewState.position.x, viewState.position.y, viewState.position.z);
    if (viewState.zoom) camera.zoom = viewState.zoom;
    console.log(`‚úì Loaded saved camera view state:`);
    console.log(`  Position: (${viewState.position.x}, ${viewState.position.y}, ${viewState.position.z})`);
    console.log(`  Target: (${viewState.target.x}, ${viewState.target.y}, ${viewState.target.z})`);
    console.log(`  Zoom: ${viewState.zoom}`);
  } else if (savedStartingCam) {
    const pos = JSON.parse(savedStartingCam);
    camera.position.set(pos.x, pos.y, pos.z);
    console.log(`‚úì Loaded saved starting camera: X=${pos.x.toFixed(2)}, Y=${pos.y.toFixed(2)}, Z=${pos.z.toFixed(2)}`);
  } else {
    camera.position.set(9.81, 13.29, -0.52);
    console.log(`‚úì Using default camera position: (9.81, 13.29, -0.52)`);
  }
  camera.updateProjectionMatrix();
  console.log("Camera created with clipping range: 0.1m - 1000m");
  
  const renderer = new THREE.WebGLRenderer({ 
    antialias: qualityLevel !== 'low', 
    powerPreference: 'high-performance',
    precision: 'highp',  // Use high precision for better shadow and lighting quality
    alpha: false
  });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(pixelRatio);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  
  // AAA-Quality adaptive tone mapping with exposure control (optimized for interior)
  if (qualityLevel === 'high') {
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3; // Slightly elevated for interior visibility
  } else if (qualityLevel === 'medium') {
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.2;
  } else {
    renderer.toneMapping = THREE.LinearToneMapping;
    renderer.toneMappingExposure = 1.0;
  }
  
  // Shadow optimization with better filtering - PCF for smooth shadows in interiors
  renderer.shadowMap.enabled = enableShadows;
  if (enableShadows) {
    // Use PCFShadowShadowMap for best quality/performance balance in AAA games
    renderer.shadowMap.type = THREE.PCFShadowShadowMap;
    renderer.shadowMap.autoUpdate = true;
    
    // Enable shadow radius blur for soft shadows (AAA trick)
    if (qualityLevel === 'high') {
      renderer.shadowMap.type = THREE.PCFShadowShadowMap; // PCF gives better blur
    }
    
    // High precision depth buffer for better shadow accuracy
    renderer.precision = 'highp';
  }
  
  // Color grading and post-processing settings
  renderer.preserveDrawingBuffer = qualityLevel === 'high'; // For better post-processing
  renderer.outputEncoding = THREE.sRGBEncoding;
  
  // Depth buffer optimization
  renderer.depth = true;
  renderer.stencil = qualityLevel === 'high';
  renderer.sortObjects = false; // Disable auto-sorting for performance - frustum culling handles this
  document.getElementById('canvas-container').appendChild(renderer.domElement);
  
  // Log optimization settings
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê RENDERING OPTIMIZATIONS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('‚úì Frustum Culling: ENABLED');
  console.log('‚úì Object Sorting: DISABLED (better batching)');
  console.log('‚úì Shadow Filtering: PCF (performance-optimized)');
  console.log('‚úì Render Only Visible: ENABLED');
  console.log('‚úì Bone Culling: ENABLED');
  console.log('‚úì Auto Quality Scaling: ENABLED (FPS < 30)');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log("Renderer created - Quality: " + qualityLevel);
  
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;
  controls.enableRotate = true;
  controls.enablePan = true;
  controls.enableZoom = true;
  controls.autoRotate = false;
  
  // Initialize visual filters
  initializeFilters();
  
  // Restore saved view state target and zoom
  if (window.savedViewState) {
    const viewState = JSON.parse(window.savedViewState);
    controls.target.set(viewState.target.x, viewState.target.y, viewState.target.z);
    console.log(`‚úì Restored controls target: (${viewState.target.x}, ${viewState.target.y}, ${viewState.target.z})`);
  } else {
    controls.target.set(-1.53, 1.44, -0.37);
    console.log(`‚úì Using default controls target: (-1.53, 1.44, -0.37)`);
  }
  
  controls.update();
  console.log("Controls created");
  
  // Dynamic camera near/far plane adjustment disabled to prevent z-fighting during zoom
  // Camera clipping planes are set to wide defaults (0.01 - 1000) which handle most cases
  
  // ============================================================================
  // TRIPLE-A QUALITY LIGHTING & SHADING SYSTEM - Advanced Global Illumination
  // ============================================================================
  
  // Sophisticated environment setup with physically-based lighting
  const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444466, qualityLevel === 'high' ? 0.5 : 0.9);
  scene.add(hemisphereLight);
  
  // Store lights for debug control
  const lights = { directional: [], point: [], spot: [] };
  
  if (enableShadows) {
    // PRIMARY LIGHT - Ultra-high quality with cascaded shadow mapping
    const dir1 = new THREE.DirectionalLight(0xffffff, qualityLevel === 'high' ? 1.3 : 0.8);
    dir1.position.set(8, 10, 6);
    dir1.castShadow = true;
    
    // Aggressive shadow optimization for 60 FPS performance
    if (qualityLevel === 'high') {
      dir1.shadow.mapSize.width = 2048; // Reduced from 4096 for better FPS
      dir1.shadow.mapSize.height = 2048;
    } else if (qualityLevel === 'med') {
      dir1.shadow.mapSize.width = 1024;
      dir1.shadow.mapSize.height = 1024;
    } else {
      // Low quality - barely visible shadows for performance
      dir1.shadow.mapSize.width = 512;
      dir1.shadow.mapSize.height = 512;
    }
    
    // Optimized shadow camera for interior with better coverage
    dir1.shadow.camera.left = -20;
    dir1.shadow.camera.right = 20;
    dir1.shadow.camera.top = 20;
    dir1.shadow.camera.bottom = -20;
    dir1.shadow.camera.near = 0.01;
    dir1.shadow.camera.far = 100;
    
    if (qualityLevel === 'high') {
      dir1.shadow.bias = -0.0008;
      dir1.shadow.normalBias = 0.04;
      dir1.shadow.radius = 12;
      dir1.shadow.blurSamples = 32;
    } else if (qualityLevel === 'medium') {
      dir1.shadow.bias = -0.0004;
      dir1.shadow.normalBias = 0.02;
      dir1.shadow.radius = 6;
    } else {
      dir1.shadow.bias = -0.0002;
      dir1.shadow.normalBias = 0.01;
      dir1.shadow.radius = 3;
    }
    
    scene.add(dir1);
    lights.directional.push(dir1);
    
    // SECONDARY FILL LIGHT - Subtle modeling light
    if (qualityLevel === 'high') {
      const dir2 = new THREE.DirectionalLight(0xeef0ff, 0.35);
      dir2.position.set(-10, 8, -8);
      dir2.castShadow = true;
      dir2.shadow.mapSize.width = 1024; // Reduced from 2048 for performance
      dir2.shadow.mapSize.height = 1024;
      dir2.shadow.camera.left = -15;
      dir2.shadow.camera.right = 15;
      dir2.shadow.camera.top = 15;
      dir2.shadow.camera.bottom = -15;
      dir2.shadow.camera.near = 0.1;
      dir2.shadow.camera.far = 100;
      dir2.shadow.bias = -0.0006;
      dir2.shadow.normalBias = 0.03;
      dir2.shadow.radius = 8;
      scene.add(dir2);
      lights.directional.push(dir2);
    } else if (qualityLevel === 'medium') {
      const dir2 = new THREE.DirectionalLight(0xeef0ff, 0.3);
      dir2.position.set(-8, 6, -6);
      dir2.castShadow = true;
      dir2.shadow.mapSize.width = 1024;
      dir2.shadow.mapSize.height = 1024;
      dir2.shadow.bias = -0.0004;
      dir2.shadow.normalBias = 0.02;
      dir2.shadow.radius = 3;
      scene.add(dir2);
      lights.directional.push(dir2);
    }
  } else {
    const dir1 = new THREE.DirectionalLight(0xffffff, 1.3);
    dir1.position.set(8, 10, 6);
    scene.add(dir1);
    lights.directional.push(dir1);
    
    const dir2 = new THREE.DirectionalLight(0xeef0ff, 0.5);
    dir2.position.set(-8, 6, -6);
    scene.add(dir2);
    lights.directional.push(dir2);
  }
  
  // ============================================================================
  // CINEMATIC ACCENT LIGHTS - Professional 3-point color-graded lighting
  // ============================================================================
  
  if (qualityLevel === 'high') {
    // KEY FILL - Cool blue accent for dimensional separation
    const keyFill = new THREE.PointLight(0x5588ff, 0.6);
    keyFill.position.set(-15, 6, 12);
    keyFill.distance = 50;
    keyFill.decay = 2;
    scene.add(keyFill);
    lights.point.push(keyFill);
    
    // RIM LIGHT - Warm golden rim for subject separation
    const rim = new THREE.PointLight(0xffdd88, 0.5);
    rim.position.set(14, 7, -12);
    rim.distance = 45;
    rim.decay = 2;
    scene.add(rim);
    lights.point.push(rim);
    
    // BACK LIGHT - Soft additional depth light
    const back = new THREE.PointLight(0xccddff, 0.25);
    back.position.set(0, 4, -15);
    back.distance = 35;
    back.decay = 2;
    scene.add(back);
    lights.point.push(back);
    
    // SUBTLE BOUNCE LIGHT - Simulates wall bounce
    const bounce = new THREE.PointLight(0xffccaa, 0.15);
    bounce.position.set(-8, 2, 8);
    bounce.distance = 30;
    bounce.decay = 2;
    scene.add(bounce);
    lights.point.push(bounce);
    
  } else if (qualityLevel === 'medium') {
    const keyFill = new THREE.PointLight(0x6699ff, 0.4);
    keyFill.position.set(-12, 5, 10);
    keyFill.distance = 40;
    keyFill.decay = 2;
    scene.add(keyFill);
    lights.point.push(keyFill);
    
    const rim = new THREE.PointLight(0xffcc99, 0.3);
    rim.position.set(12, 6, -10);
    rim.distance = 35;
    rim.decay = 2;
    scene.add(rim);
    lights.point.push(rim);
  }
  
  console.log("‚úì TRIPLE-A QUALITY LIGHTING SYSTEM (" + qualityLevel + ")");
  console.log("  ‚Ä¢ Advanced shadow mapping (PCF filtering)");
  console.log("  ‚Ä¢ 3-point cinematic lighting");
  
  // ============================================================================
  // ADVANCED POST-PROCESSING EFFECTS - Professional Quality
  // ============================================================================
  
  window.postProcessingEnabled = qualityLevel === 'high';
  window.bloomStrength = 1.2;
  window.bloomThreshold = 0.7;
  window.bloomRadius = 0.8;
  
  // Custom post-processing shaders for AAA quality
  const postProcessShaders = {
    // Enhanced bloom shader with better color preservation
    bloom: {
      uniforms: {
        tDiffuse: { value: null },
        bloomStrength: { value: 1.0 },
        bloomRadius: { value: 0.8 },
        bloomThreshold: { value: 0.7 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float bloomStrength;
        uniform float bloomRadius;
        uniform float bloomThreshold;
        varying vec2 vUv;
        
        void main() {
          vec4 texel = texture2D(tDiffuse, vUv);
          float brightness = (texel.r + texel.g + texel.b) / 3.0;
          
          if (brightness > bloomThreshold) {
            vec4 bloom = texel * bloomStrength;
            
            // Multi-tap gaussian blur for smooth bloom
            for(int i = -3; i <= 3; i++) {
              for(int j = -3; j <= 3; j++) {
                float weight = exp(-float(i*i + j*j) / (2.0 * bloomRadius * bloomRadius));
                bloom += texture2D(tDiffuse, vUv + vec2(float(i), float(j)) * 0.0015 * bloomRadius) * weight * bloomStrength;
              }
            }
            
            gl_FragColor = mix(texel, bloom, 0.3);
          } else {
            gl_FragColor = texel;
          }
        }
      `
    },
    
    // Color grading shader with filmic tone curve
    colorGrade: {
      uniforms: {
        tDiffuse: { value: null },
        exposure: { value: 1.2 },
        saturation: { value: 1.1 },
        contrast: { value: 1.15 },
        warmth: { value: 0.1 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float exposure;
        uniform float saturation;
        uniform float contrast;
        uniform float warmth;
        varying vec2 vUv;
        
        vec3 filmicToneMap(vec3 x) {
          float A = 0.15;
          float B = 0.50;
          float C = 0.10;
          float D = 0.20;
          float E = 0.02;
          float F = 0.30;
          return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
        }
        
        void main() {
          vec4 texel = texture2D(tDiffuse, vUv);
          
          // Apply exposure
          vec3 color = texel.rgb * exposure;
          
          // Filmic tone mapping
          color = filmicToneMap(color) / filmicToneMap(vec3(11.2));
          
          // Saturation
          vec3 gray = vec3(dot(color, vec3(0.299, 0.587, 0.114)));
          color = mix(gray, color, saturation);
          
          // Contrast
          color = mix(vec3(0.5), color, contrast);
          
          // Subtle warmth shift
          color.rb += warmth * 0.15;
          
          gl_FragColor = vec4(color, texel.a);
        }
      `
    },
    
    // Screen-space reflections approximation
    ssrGloss: {
      uniforms: {
        tDiffuse: { value: null },
        ssrIntensity: { value: 0.3 },
        ssrRoughness: { value: 0.5 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float ssrIntensity;
        uniform float ssrRoughness;
        varying vec2 vUv;
        
        void main() {
          vec4 texel = texture2D(tDiffuse, vUv);
          
          // Subtle horizon reflection effect
          vec2 horizonUv = vUv;
          horizonUv.y = 1.0 - horizonUv.y;
          
          vec4 horizonColor = texture2D(tDiffuse, horizonUv * 0.1 + 0.45);
          
          // Apply to glossy surfaces (brighter areas)
          float brightness = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
          vec4 reflection = mix(texel, horizonColor, brightness * ssrIntensity * (1.0 - ssrRoughness));
          
          gl_FragColor = reflection;
        }
      `
    }
  };
  
  console.log("‚úì Advanced post-processing shaders loaded");
  
  const loader = new GLTFLoader();
  
  // Set up DRACO decompression for compressed models
  try {
    const dracoLoader = new DRACOLoader();
    // Use a relative path if DRACO files are in same directory, otherwise use CDN
    dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
    loader.setDRACOLoader(dracoLoader);
    console.log("‚úì DRACO loader configured");
  } catch(err) {
    console.warn("‚ö† DRACO loader setup warning:", err);
    // Continue without DRACO - some models don't need it
  }
  
  let root = null;
  let initialCam = camera.position.clone();
  let initialTarget = controls.target.clone();
  let isAnimationPlaying = false; // Track if animation is active
  
  // Global variables for interaction and collision
  let borderMeshes = [];
  let cameraCollisionEnabled = false;
  let collisionRadius = 0.08; // Global collision radius - adjustable via UI
  let collisionSmoothFactor = 0.15; // Global smooth factor - adjustable via UI
  let bones = [];
  let boneHelpers = {};
  let selectedBone = null;
  let freeplayBone = null; // Special bone for freeplay interaction
  let bonesVisible = false; // Bones hidden by default
  let selectedObject = null;
  let selectedMaterial = null;
  let cursor3D = null;
  let cursor3DRing = null;
  let cursorFadeOutTimeout = null;
  let cursorAnimFrame = null;
  
  // Global constants for interaction
  const GRID_SNAP = 0.25; // Snap to 0.25 unit grid
  const DRAG_SENSITIVITY = 1.0;
  const ROTATION_SENSITIVITY = 0.5;
  const BONE_INTERACTION_RADIUS = 0.3; // Radius for bone interaction detection
  
  console.log("Loader created with DRACO support");
  
  function frame(obj){
    // Skip auto-framing if we have a saved view state (user has positioned camera)
    if (window.savedViewState || localStorage.getItem('startingCameraPos')) {
      console.log("Skipping auto-frame - using saved camera position");
      return;
    }
    
    const box = new THREE.Box3().setFromObject(obj);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    const maxDim = Math.max(size.x,size.y,size.z) || 1;
    const fov = camera.fov*Math.PI/180;
    let z=(maxDim/2)/Math.tan(fov/2);
    z*=0.8; // Closer zoom (was 1.35)
    camera.position.set(center.x+z*0.65, center.y+z*0.5, center.z+z);
    camera.near=Math.max(0.001,maxDim/1000);
    camera.far=Math.max(100,maxDim*50);
    camera.updateProjectionMatrix();
    controls.target.copy(center);
    controls.update();
  }
  
  // Function to start loading the scene - called when assets are ready
  function startExperience() {
    // Ensure renderer is sized correctly for the current viewport
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(pixelRatio);
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    
    console.log("About to call loader.load() with URL:", MODEL_URL);
    statusEl.textContent = "Starting to load GLB...";
    
    loader.load(MODEL_URL,(gltf)=>{
    console.log("‚úì Model loaded successfully!",gltf);
    statusEl.textContent = "Model loaded!";
    root=gltf.scene;
    scene.add(root);
    console.log("[DEBUG] Scene has", scene.children.length, "objects after adding model");
    
    // Check if there's a camera in the exported scene
    let cameraFound = false;
    root.traverse((obj) => {
      if (obj.isCamera && !cameraFound) {
        // Use the Blender camera
        camera.position.copy(obj.position);
        camera.rotation.copy(obj.rotation);
        camera.fov = obj.fov || 45;
        camera.near = obj.near || 0.01;
        camera.far = obj.far || 500;
        camera.updateProjectionMatrix();
        
        cameraFound = true;
        console.log("Using Blender camera from GLB");
        console.log("Camera position:", camera.position);
        console.log("Camera FOV:", camera.fov);
      }
    });
    
    // Animation mixer setup
    window.mixer = new THREE.AnimationMixer(root);
    window.actions = {};
    window.currentAction = null;
    window.animationClip = null;
    window.transitionedThisClip = false; // Flag to prevent spam
    
    // Detect animations
    const animations = gltf.animations;
    const bonesPanel = document.getElementById("bones-panel");
    const dropdown = document.getElementById("animation-dropdown");
    
    // Store globally for animation chaining
    window.animationsArray = animations;
    
    // ===== CAMERA ANIMATION DETECTION =====
    // Scan all animations for camera tracks
    window.cameraAnimations = {}; // Maps animation name -> camera data
    window.cameraAnimationBone = null; // The bone that controls camera (if any)
    
    if (animations && animations.length > 0) {
      // Filter out invalid animations (must have tracks and non-zero duration)
      const validAnimations = animations.filter(a => a.tracks && a.tracks.length > 0 && a.duration > 0);
      
      // Check each animation for camera-related tracks
      validAnimations.forEach((clip) => {
        const cameraTracks = clip.tracks.filter(track => {
          const trackName = track.name.toLowerCase();
          return trackName.includes('camera') || trackName.includes('cam');
        });
        
        if (cameraTracks.length > 0) {
          window.cameraAnimations[clip.name] = {
            hasCameraAnimation: true,
            trackNames: cameraTracks.map(t => t.name),
            duration: clip.duration
          };
          console.log(`üì∑ Camera animation detected in "${clip.name}": ${cameraTracks.map(t => t.name).join(', ')}`);
        }
      });
      
      // Also detect camera bone in hierarchy
      root.traverse((obj) => {
        const name = obj.name.toLowerCase();
        if ((name.includes('camera') || name.includes('cam')) && !obj.isCamera) {
          window.cameraAnimationBone = obj;
          console.log(`üì∑ Found camera animation bone: ${obj.name}`);
        }
      });
      
      console.log("Available animations:", validAnimations.map(a => a.name));
      
      if (validAnimations.length > 0) {
        // Panel is now visible by default (display: flex in CSS)
        // Note: bonesPanel.style.display = "none" removed to keep it visible on start
        
        // Log all valid animations to console
        validAnimations.forEach((clip, idx) => {
          console.log(`[${idx}] ${clip.name}: ${clip.duration.toFixed(3)}s, tracks: ${clip.tracks.length}`);
        });
        
        // Populate dropdown with valid animations only
        validAnimations.forEach((clip) => {
          const option = document.createElement("option");
          option.value = clip.name;
          // Format: Animation Name (Duration)
          option.textContent = `${clip.name} (${clip.duration.toFixed(2)}s)`;
          dropdown.appendChild(option);
          
          // Store action for each animation and configure it
          const action = window.mixer.clipAction(clip);
          action.loop = THREE.LoopOnce; // Default to no looping
          action.clampWhenFinished = true; // Hold last frame when finished
          
          window.actions[clip.name] = action;
        });
        
        // Store valid animations array for chaining
        window.animationsArray = validAnimations;
      } else {
        // No valid animations found
        console.warn("No valid animations found in model");
        // Keep panel visible even without animations
      }
    } else {
      // No animations at all
      console.log("Model has no animations");
      // Keep panel visible even without animations
    }
    
    // Setup animation controls
    dropdown.addEventListener("change", (e) => {
      const clipName = e.target.value;
      if (clipName && window.animationsArray) {
        window.animationClip = window.animationsArray.find(a => a.name === clipName);
        window.currentAction = window.actions[clipName];
        
        if (window.animationClip) {
          // Update UI with animation details
          document.getElementById("anim-duration").textContent = window.animationClip.duration.toFixed(2);
          document.getElementById("anim-info").textContent = `${clipName} - ${window.animationClip.duration.toFixed(2)}s`;
          document.getElementById("anim-timeline").max = 10000; // 0-10000 for 0.01s precision
          
          // Reset timeline
          document.getElementById("anim-timeline").value = 0;
          document.getElementById("anim-time").textContent = "0.00";
          
          // Reset mixer time
          window.mixer.time = 0;
          
          // Reset transition flag for new clip
          window.transitionedThisClip = false;
          
          // Stop all other animations
          window.mixer.stopAllAction();
          
          // Set loop mode from checkbox
          window.currentAction.loop = document.getElementById("anim-loop").checked ? THREE.LoopRepeat : THREE.LoopOnce;
          window.currentAction.clampWhenFinished = !document.getElementById("anim-loop").checked;
          
          // Auto play if enabled
          if (document.getElementById("anim-autoplay").checked) {
            window.currentAction.reset();
            window.currentAction.play();
            
            // Lock camera during autoplay
            isAnimationPlaying = true;
            controls.enableRotate = false;
            controls.enablePan = false;
            controls.enableZoom = false;
            console.log("‚úì Camera controls locked during autoplay animation");
          }
          
          console.log("‚úì Selected animation:", clipName, "Duration:", window.animationClip.duration.toFixed(2) + "s");
        }
      }
    });
    
    // Play/Pause/Stop controls
    document.getElementById("anim-play").addEventListener("click", () => {
      if (window.currentAction && window.animationClip) {
        console.log("Playing:", window.animationClip.name);
        window.mixer.timeScale = 1;
        window.currentAction.reset();
        window.currentAction.play();
        
        // Lock camera during animation
        isAnimationPlaying = true;
        controls.enableRotate = false;
        controls.enablePan = false;
        controls.enableZoom = false;
        console.log("‚úì Camera controls locked during animation");
      }
    });
    
    document.getElementById("anim-pause").addEventListener("click", () => {
      if (window.currentAction) {
        window.mixer.timeScale = window.mixer.timeScale === 0 ? 1 : 0;
        console.log(window.mixer.timeScale === 0 ? "Paused" : "Resumed");
      }
    });
    
    document.getElementById("anim-stop").addEventListener("click", () => {
      if (window.currentAction) {
        window.mixer.timeScale = 1;
        window.currentAction.stop();
        window.mixer.time = 0;
        document.getElementById("anim-timeline").value = 0;
        document.getElementById("anim-time").textContent = "0.00";
        
        // Unlock camera when animation stops
        isAnimationPlaying = false;
        controls.enableRotate = true;
        controls.enablePan = true;
        controls.enableZoom = true;
        console.log("‚úì Camera controls unlocked - animation stopped");
      }
    });
    
    // Timeline scrubbing with high precision (0.01s steps)
    document.getElementById("anim-timeline").addEventListener("input", (e) => {
      if (window.currentAction && window.animationClip) {
        // Convert from 0-10000 range to 0-1 progress, then to time
        const progress = parseFloat(e.target.value) / 10000;
        const time = progress * window.animationClip.duration;
        
        // Clamp time to valid range
        const clampedTime = Math.max(0, Math.min(time, window.animationClip.duration));
        
        // Set mixer time and update frame immediately
        window.mixer.time = clampedTime;
        window.mixer.update(0);
        document.getElementById("anim-time").textContent = clampedTime.toFixed(2);
        
        // Reset transition flag when scrubbing
        window.transitionedThisClip = false;
      }
    });
    
    // Loop toggle
    document.getElementById("anim-loop").addEventListener("change", (e) => {
      if (window.currentAction) {
        window.currentAction.loop = e.target.checked ? THREE.LoopRepeat : THREE.LoopOnce;
        window.currentAction.clampWhenFinished = !e.target.checked;
        console.log("Loop:", e.target.checked);
      }
    });
    
    // Speed control
    document.getElementById("anim-speed").addEventListener("input", (e) => {
      const speed = parseFloat(e.target.value);
      window.mixer.timeScale = speed;
      document.getElementById("speed-value").textContent = speed.toFixed(1);
      console.log("Animation speed:", speed);
    });
    
    // Animation sequence chaining
    const sequenceToggle = document.getElementById("sequence-mode");
    const sequenceInfo = document.getElementById("sequence-info");
    
    sequenceToggle.addEventListener("change", (e) => {
      window.sequenceMode = e.target.checked;
      sequenceInfo.style.display = e.target.checked ? "block" : "none";
      
      // Update sequence text dynamically
      if (window.animationNames && window.animationNames.length > 0) {
        const chain = window.animationNames.join(" ‚Üí ");
        document.getElementById("sequence-text").textContent = chain;
      }
      
      console.log("Sequence mode:", e.target.checked);
    });
    
    // Store animation names for chaining
    if (window.animationsArray && window.animationsArray.length > 0) {
      window.animationNames = window.animationsArray.map(a => a.name);
      
      // Auto-select first animation
      const firstClip = window.animationsArray[0];
      window.animationClip = firstClip;
      window.currentAction = window.actions[firstClip.name];
      
      dropdown.value = firstClip.name;
      document.getElementById("anim-duration").textContent = firstClip.duration.toFixed(2);
      document.getElementById("anim-info").textContent = `${firstClip.name} - ${firstClip.duration.toFixed(2)}s`;
      document.getElementById("anim-timeline").max = 10000; // 0-10000 for 0.01s precision
      
      // Enable chain animations only if there are 2+ animations
      if (window.animationsArray.length >= 2) {
        sequenceToggle.disabled = false;
        document.getElementById("sequence-label").textContent = "Chain Animations";
      } else {
        sequenceToggle.disabled = true;
        document.getElementById("sequence-label").textContent = "Chain Animations (need 2+ animations)";
      }
      
      console.log("‚úì Auto-selected first animation:", firstClip.name);
    }
    
    root.traverse((o)=>{
      if(o.isMesh){
        // Calculate mesh thickness to identify thin geometry (like bills, paper)
        const bbox = new THREE.Box3().setFromObject(o);
        const size = bbox.getSize(new THREE.Vector3());
        const minDim = Math.min(size.x, size.y, size.z);
        const isThinGeometry = minDim < 0.1; // Less than 0.1 units thick
        
        o.castShadow = enableShadows;
        // Disable shadow receiving on very thin geometry to prevent artifacts
        o.receiveShadow = enableShadows && !isThinGeometry;
        // Use DoubleSide to ensure textures visible from both sides (interior room)
        o.material.side = THREE.DoubleSide;
        o.frustumCulled = false; // Disable frustum culling for room interiors
        o.matrixAutoUpdate = true; // Ensure transforms update correctly
        
        // === INTERIOR ROOM MATERIAL OPTIMIZATION ===
        const mat = o.material;
        
        // Fix z-fighting and polygon artifacts for double-sided rendering
        // Disable polygon offset for thin geometry to prevent flickering
        if (!isThinGeometry) {
          mat.polygonOffset = true;
          mat.polygonOffsetFactor = 0.5;
          mat.polygonOffsetUnits = 0.5;
        }
        
        // For DoubleSide rendering, reduce normal map intensity to prevent harsh shadows on backfaces
        if (mat.normalMap) {
          if (isThinGeometry) {
            // Disable normal maps for thin geometry (bills, paper) - causes banding/harsh lines
            mat.normalMap = null;
            mat.normalScale.set(0, 0);
          } else if (qualityLevel === 'high') {
            mat.normalScale.multiplyScalar(0.9); // Soften normal detail on backfaces
          } else if (qualityLevel === 'medium') {
            mat.normalScale.multiplyScalar(0.8);
          } else {
            mat.normalScale.multiplyScalar(0.7);
          }
        }
        
        // Prevent overly bright materials and specular highlights
        if (mat.metalness !== undefined) {
          mat.metalness = Math.min(mat.metalness, 0.6);
        }
        if (mat.roughness !== undefined) {
          mat.roughness = Math.max(mat.roughness, 0.2); // Minimum roughness for interior spaces
        }
        
        // Reduce emissive bleeding that causes artifacts
        if (mat.emissiveIntensity !== undefined) {
          mat.emissiveIntensity = Math.min(mat.emissiveIntensity, 0.3);
        }
        
        // AAA-Quality material settings with anti-flicker optimization
        if (qualityLevel === 'high') {
          // Maximum quality material settings
          mat.shadowSide = THREE.DoubleSide;  // Proper shadow rendering for interior
          mat.dithering = true; // Better color banding prevention
          mat.flatShading = false; // Smooth shading for interior
          
          // Maximum anisotropic filtering for sharp textures (reduced for thin geometry)
          const maxAniso = isThinGeometry ? 1 : 16;
          if (mat.map) {
            mat.map.anisotropy = maxAniso;
            // Use simpler filters for thin geometry to prevent warping
            if (isThinGeometry) {
              mat.map.magFilter = THREE.LinearFilter;
              mat.map.minFilter = THREE.LinearFilter; // No mipmaps for thin geometry
              mat.map.generateMipmaps = false; // Disable mipmap generation
            }
          }
          
          // PBR material enhancements
          if (mat.metalnessMap) {
            mat.metalnessMap.anisotropy = isThinGeometry ? 1 : 8;
          }
          if (mat.roughnessMap) {
            mat.roughnessMap.anisotropy = isThinGeometry ? 1 : 8;
          }
          if (mat.normalMap) {
            mat.normalMap.anisotropy = isThinGeometry ? 0 : 8;
          }
          
        } else if (qualityLevel === 'medium') {
          // Balanced quality settings
          mat.shadowSide = THREE.DoubleSide;
          mat.dithering = true;
          if (mat.map) {
            mat.map.anisotropy = isThinGeometry ? 1 : 8;
            if (isThinGeometry) {
              mat.map.magFilter = THREE.LinearFilter;
              mat.map.minFilter = THREE.LinearFilter;
              mat.map.generateMipmaps = false;
            }
          }
          
        } else {
          // Low-end optimized
          mat.shadowSide = THREE.DoubleSide;
          if (mat.map) {
            mat.map.anisotropy = 4;
          }
        }
        
        // ===== INTERIOR SPACE LIGHTING ADJUSTMENTS =====
        // For interior rooms, boost ambient lighting on materials
        if (mat.color) {
          // Don't over-darken room materials
          const brightness = (mat.color.r + mat.color.g + mat.color.b) / 3;
          if (brightness < 0.3) {
            mat.color.multiplyScalar(1.1); // Slightly brighten dark surfaces
          }
        }
      }
    });
    
    // === PBR TEXTURE ENHANCEMENT ===
    // Auto-detect and enhance PBR materials from baked textures with AAA-quality tricks
    const materialStats = { count: 0, pbr: 0, enhanced: 0, visible: 0 };
    const visibleMaterials = [];
    const maxAnisotropy = renderer.capabilities.maxAnisotropy;
    
    root.traverse(obj => {
      if (obj.isMesh && obj.material) {
        materialStats.count++;
        const mat = obj.material;
        
        // Log material visibility
        if (!obj.visible) {
          console.warn(`  ‚ö† Mesh "${obj.name}" is hidden (visible=false)`);
        } else {
          materialStats.visible++;
        }
        
        // If material has textures, it's likely from baked Blender export
        if (mat.map || mat.normalMap || mat.roughnessMap || mat.metalnessMap) {
          materialStats.pbr++;
          visibleMaterials.push({name: obj.name, color: mat.map ? 'textured' : 'colored'});
          
          // ========================================
          // ADVANCED NORMAL MAPPING
          // ========================================
          if (mat.normalMap) {
            // Enhanced normal detail with anisotropic filtering
            mat.normalScale.multiplyScalar(qualityLevel === 'high' ? 1.5 : 1.2);
            mat.normalMap.magFilter = THREE.LinearFilter;
            mat.normalMap.minFilter = THREE.LinearMipmapLinearFilter;
            mat.normalMap.anisotropy = qualityLevel === 'high' ? maxAnisotropy : 8;
            materialStats.enhanced++;
          }
          
          // ========================================
          // METALNESS WITH MICRO-DETAIL
          // ========================================
          if (mat.metalnessMap) {
            mat.metalness = qualityLevel === 'high' ? 0.9 : 0.75;
            mat.metalnessMap.magFilter = THREE.LinearFilter;
            mat.metalnessMap.minFilter = THREE.LinearMipmapLinearFilter;
            mat.metalnessMap.anisotropy = qualityLevel === 'high' ? maxAnisotropy : 6;
            
            // Micro-surface roughness for realistic wear
            mat.roughness = qualityLevel === 'high' ? 0.1 : 0.2;
          }
          
          // ========================================
          // ADVANCED ROUGHNESS MAPPING
          // ========================================
          if (mat.roughnessMap) {
            mat.roughness = qualityLevel === 'high' ? 0.55 : 0.65;
            mat.roughnessMap.magFilter = THREE.LinearFilter;
            mat.roughnessMap.minFilter = THREE.LinearMipmapLinearFilter;
            mat.roughnessMap.anisotropy = qualityLevel === 'high' ? maxAnisotropy : 6;
          } else {
            mat.roughness = qualityLevel === 'high' ? 0.4 : 0.55;
          }
          
          // ========================================
          // ENVIRONMENT MAPPING & FRESNEL
          // ========================================
          if (mat.envMap) {
            // Enhanced reflections for photorealism
            mat.envMapIntensity = qualityLevel === 'high' ? 1.6 : 1.0;
            if (mat instanceof THREE.MeshPhysicalMaterial) {
              mat.reflectivity = 0.95;
            }
          }
          
          // ========================================
          // AMBIENT OCCLUSION WITH ENHANCED INTENSITY
          // ========================================
          if (mat.aoMap) {
            mat.aoMapIntensity = qualityLevel === 'high' ? 1.2 : 0.9;
            mat.aoMap.magFilter = THREE.LinearFilter;
            mat.aoMap.minFilter = THREE.LinearMipmapLinearFilter;
            mat.aoMap.anisotropy = qualityLevel === 'high' ? maxAnisotropy : 6;
          }
          
          // ========================================
          // EMISSIVE MAPPING (GLOWING TEXTURES)
          // ========================================
          if (mat.emissiveMap) {
            mat.emissiveIntensity = qualityLevel === 'high' ? 2.5 : 1.5;
            mat.emissiveMap.magFilter = THREE.LinearFilter;
            mat.emissiveMap.minFilter = THREE.LinearMipmapLinearFilter;
          } else if (mat.emissive && mat.emissive.getHex() > 0) {
            mat.emissiveIntensity = qualityLevel === 'high' ? 2.0 : 1.0;
          }
          
          // ========================================
          // DIFFUSE/ALBEDO MAP ENHANCEMENT
          // ========================================
          if (mat.map) {
            mat.map.magFilter = THREE.LinearFilter;
            mat.map.minFilter = THREE.LinearMipmapLinearFilter;
            mat.map.colorSpace = THREE.SRGBColorSpace;
            mat.map.anisotropy = qualityLevel === 'high' ? maxAnisotropy : 8;
            
            // Color space correction
            if (mat.color) {
              mat.color.multiplyScalar(qualityLevel === 'high' ? 1.05 : 1.0);
            }
          }
          
          // ========================================
          // DISPLACEMENT & HEIGHT MAPPING (if available)
          // ========================================
          if (mat.displacementMap) {
            mat.displacementScale = qualityLevel === 'high' ? 0.3 : 0.15;
            mat.displacementBias = 0.0;
          }
        }
        
        // ========================================
        // GLOBAL PBR SETTINGS
        // ========================================
        if (mat instanceof THREE.MeshStandardMaterial || mat instanceof THREE.MeshPhysicalMaterial) {
          mat.envMapIntensity = qualityLevel === 'high' ? 1.4 : 1.0;
          mat.reflectivity = 0.9;
          mat.side = THREE.DoubleSide; // Better light interaction
          
          // Physical material enhancements
          if (mat instanceof THREE.MeshPhysicalMaterial) {
            // Clearcoat simulation for realistic finish
            mat.clearcoat = qualityLevel === 'high' ? 0.1 : 0.05;
            mat.clearcoatRoughness = qualityLevel === 'high' ? 0.1 : 0.15;
          }
        }
      }
    });
    
    console.log(`‚úì MATERIAL SETUP: ${materialStats.count} total, ${materialStats.visible} visible`);
    console.log(`  ‚úì Advanced PBR: ${materialStats.pbr} materials enhanced`);
    console.log(`  ‚úì Techniques: Anisotropic filtering, Clearcoat, Enhanced Fresnel`);
    
    // Add subtle fill light for interior spaces (prevents complete darkness in corners)
    const fillLight = new THREE.PointLight(0xccccdd, 0.3, 60);
    fillLight.position.set(0, 1, 0);
    scene.add(fillLight);
    console.log(`‚úì Interior fill light added for corner brightening`);
    
    // === RENDERING MODES ===
    window.renderingMode = 'standard'; // 'standard', 'eevee', 'cycles'
    
    function applyRenderingMode(mode) {
      window.renderingMode = mode;
      const lightAdjustments = {
        standard: { exposure: 1.3, intensity: 1.0, shadowMap: 2048 },
        eevee: { exposure: 1.1, intensity: 1.3, shadowMap: 2048 }, // Crisp, real-time optimized
        cycles: { exposure: 1.4, intensity: 0.9, shadowMap: 4096 } // Photorealistic, baked quality
      };
      
      const settings = lightAdjustments[mode] || lightAdjustments.standard;
      renderer.toneMappingExposure = settings.exposure;
      
      // Adjust lights
      scene.children.forEach(obj => {
        if (obj.isLight) {
          if (obj.intensity !== undefined) {
            obj.intensity = settings.intensity;
          }
          if (obj.isShadowLight) {
            obj.shadow.mapSize.width = settings.shadowMap;
            obj.shadow.mapSize.height = settings.shadowMap;
            obj.shadow.map = null; // Force shadow map update
          }
        }
      });
      
      // Adjust model materials based on mode
      root.traverse(obj => {
        if (obj.isMesh && obj.material) {
          const mat = obj.material;
          switch(mode) {
            case 'eevee':
              // Crisp, real-time rendering - enhance colors slightly
              if (mat.color) mat.color.multiplyScalar(1.05);
              if (mat.metalness !== undefined) mat.metalness *= 0.9; // Slightly reduce for crispness
              break;
            case 'cycles':
              // Photorealistic - reduce brightness for baked quality feel
              if (mat.color) mat.color.multiplyScalar(0.95);
              if (mat.metalness !== undefined) mat.metalness *= 1.1; // Enhance metallic details
              break;
            case 'standard':
            default:
              // Balanced rendering
              break;
          }
        }
      });
      
      console.log(`‚úì Rendering Mode: ${mode.toUpperCase()}`);
    }
    
    // Initialize with standard mode
    applyRenderingMode('standard');
    
    // Performance optimization: enable frustum culling
    scene.traverse(obj => {
      if (obj.isMesh) {
        obj.frustumCulled = true;
        obj.matrixAutoUpdate = true;
      }
    });
    
    console.log('=== Scene Object Hierarchy ===');
    const logTree = (obj, depth = 0) => {
      const indent = '  '.repeat(depth);
      const type = obj.isMesh ? '[MESH]' : '[GROUP]';
      console.log(`${indent}${obj.name || 'unnamed'} ${type}`);
      if (obj.children && obj.children.length > 0) {
        obj.children.forEach(child => logTree(child, depth + 1));
      }
    };
    root.children.forEach(child => logTree(child, 0));
    console.log('========================');
    if (!cameraFound) {
      // Using hardcoded camera position, skip auto-frame
      controls.target.set(0, 0, 0);
      controls.update();
      console.log("Using hardcoded camera position");
    } else {
      // Found Blender camera, skip auto-frame
      controls.target.set(0, 0, 0);
      controls.update();
      console.log("Using Blender camera");
    }
    
    // Always call frame to ensure proper camera positioning
    frame(root);
    
    initialCam=camera.position.clone();
    initialTarget=controls.target.clone();
    
    // Initialize border collision system
    initializeBorderCollision();
    
    // Skip collision check on initial spawn - allow free placement
    window.skipCollisionCheck = true;
    setTimeout(() => {
      window.skipCollisionCheck = false;
      console.log("‚úì Collision detection enabled");
    }, 500);
    },(progress)=>{
    const pct = Math.min(Math.round(progress.loaded/progress.total*100), 100);
    console.log("Loading:",pct+"%",progress.loaded,"/",progress.total);
    statusEl.textContent = `Loading: ${pct}%`;
  },(e)=>{
    console.error("‚úó Failed to load model:",e);
    const errorMsg = e?.message || e?.toString() || "Unknown error";
    statusEl.textContent = `Error: ${errorMsg}`;
    alert("Failed to load GLB: " + errorMsg);
    
    // Add test cube if model fails
    const geo=new THREE.BoxGeometry(1,1,1);
    const mat=new THREE.MeshStandardMaterial({color:0xff0000});
    root=new THREE.Mesh(geo,mat);
    scene.add(root);
    frame(root);
  });
  }
  
  // Automatically start experience on page load
  window.addEventListener('load', () => {
    startExperience();
  });
  
  // Hide birthday message overlay when clicked
  const birthdayMessage = document.getElementById('birthday-message');
  if (birthdayMessage) {
    birthdayMessage.addEventListener('click', () => {
      birthdayMessage.style.opacity = '0';
      birthdayMessage.style.pointerEvents = 'none';
      birthdayMessage.style.transition = 'opacity 0.5s ease-out';
      console.log('Birthday message dismissed');
    });
  }
  
  console.log("loader.load() ready to call!");
  
  const btnReset=document.getElementById("reset");
  const btnAuto=document.getElementById("auto");
  const btnFullscreen=document.getElementById("fullscreen");
  const btnDownload=document.getElementById("download");
  const perfMonitor=document.getElementById("perf-monitor");
  let auto=false;
  
  // Reset view - use saved view state if available, otherwise use initial positions
  btnReset.onclick=()=>{
    const savedViewState = localStorage.getItem('cameraViewState');
    if (savedViewState) {
      const viewState = JSON.parse(savedViewState);
      camera.position.set(viewState.position.x, viewState.position.y, viewState.position.z);
      controls.target.set(viewState.target.x, viewState.target.y, viewState.target.z);
      if (viewState.zoom) camera.zoom = viewState.zoom;
    } else {
      camera.position.copy(initialCam);
      controls.target.copy(initialTarget);
    }
    controls.update();
  };
  btnAuto.onclick=()=>{auto=!auto;controls.autoRotate=auto;btnAuto.textContent=`Auto-rotate: ${auto?"On":"Off"}`;};
  btnFullscreen.onclick=()=>{
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => console.error(err));
    } else {
      document.exitFullscreen();
    }
  };
  
  // Toggle performance monitor
  document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'p') {
      perfMonitor.style.display = perfMonitor.style.display === 'none' ? 'block' : 'none';
    }
  });
  
  // Debug menu toggle with Ctrl+Shift+D (password protected)
  const debugMenu = document.getElementById('debug-menu');
  const DEV_CONSOLE_PASSWORD = 'lbrbxayb';
  let devConsoleUnlocked = false;
  
  // Copy camera position button
  const copyBtn = document.getElementById('debug-copy-camera');
  if (copyBtn) {
    copyBtn.addEventListener('click', () => {
      const camPos = `${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}`;
      navigator.clipboard.writeText(camPos).then(() => {
        const originalText = copyBtn.textContent;
        copyBtn.textContent = '‚úì Copied!';
        copyBtn.style.background = '#00aa00';
        setTimeout(() => {
          copyBtn.textContent = originalText;
          copyBtn.style.background = '#00ff00';
        }, 2000);
      }).catch(err => console.error('Failed to copy:', err));
    });
  }
  
  // Save camera view state as default
  const saveBtn = document.getElementById('debug-save-camera');
  if (saveBtn) {
    saveBtn.addEventListener('click', () => {
      const viewState = {
        position: {
          x: parseFloat(camera.position.x.toFixed(4)),
          y: parseFloat(camera.position.y.toFixed(4)),
          z: parseFloat(camera.position.z.toFixed(4))
        },
        target: {
          x: parseFloat(controls.target.x.toFixed(4)),
          y: parseFloat(controls.target.y.toFixed(4)),
          z: parseFloat(controls.target.z.toFixed(4))
        },
        zoom: parseFloat(camera.zoom.toFixed(4))
      };
      
      // Save both for backward compatibility
      localStorage.setItem('startingCameraPos', JSON.stringify(viewState.position));
      localStorage.setItem('cameraViewState', JSON.stringify(viewState));
      
      // Enhanced logging with verification
      console.log('‚úì Camera view state saved:', viewState);
      console.log('  Position:', `(${viewState.position.x}, ${viewState.position.y}, ${viewState.position.z})`);
      console.log('  Target:', `(${viewState.target.x}, ${viewState.target.y}, ${viewState.target.z})`);
      console.log('  Zoom:', viewState.zoom);
      
      // Verify it was saved correctly
      const saved = localStorage.getItem('cameraViewState');
      const verified = JSON.parse(saved);
      console.log('‚úì Verification - saved to localStorage:', verified);
      
      const originalText = saveBtn.textContent;
      saveBtn.textContent = '‚úì Saved!';
      saveBtn.style.background = '#00aa00';
      setTimeout(() => {
        saveBtn.textContent = originalText;
        saveBtn.style.background = '#00aaff';
      }, 2000);
    });
  }
  
  // Jailbreak mode - sleek hacker aesthetic (dev-only feature)
  let osJailbroken = localStorage.getItem('neuronOS_jailbroken') === 'true';
  
  function applyJailbreakTheme() {
    osJailbroken = true;
    localStorage.setItem('neuronOS_jailbroken', 'true');
    
    const style = document.createElement('style');
    style.id = 'jailbreak-theme';
    style.textContent = `
      /* JAILBROKEN OS - INTENSE HACKER AESTHETIC WITH VHS & JARVIS HUD */
      
      /* INTENSE SCREEN EFFECTS */
      body {
        background: #0a0e27 !important;
        filter: contrast(1.1) brightness(0.95) !important;
        animation: vhsJitter 0.06s infinite !important;
      }
      
      canvas {
        background: linear-gradient(to bottom, #0a0e27, #1a1f3a) !important;
        box-shadow: inset 0 0 100px rgba(0, 255, 65, 0.08) !important;
        filter: saturate(1.2) !important;
      }
      
      /* AGGRESSIVE VHS JITTER & GLITCH */
      @keyframes vhsJitter {
        0% { transform: translateX(0) translateY(0); }
        20% { transform: translateX(1px) translateY(-1px); }
        40% { transform: translateX(-1px) translateY(1px); }
        60% { transform: translateX(0.5px) translateY(-0.5px); }
        80% { transform: translateX(-0.5px) translateY(0.5px); }
        100% { transform: translateX(0) translateY(0); }
      }
      
      /* INTENSE SCANLINES - FLICKERING CRT */
      body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.25),
          rgba(0, 0, 0, 0.25) 1px,
          rgba(255, 0, 0, 0.02) 1px,
          rgba(255, 0, 0, 0.02) 2px
        );
        pointer-events: none;
        z-index: 9998;
        animation: scanlineFlicker 0.15s infinite, scanlineMove 8s linear infinite;
      }
      
      @keyframes scanlineFlicker {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 0.95; }
      }
      
      @keyframes scanlineMove {
        0% { transform: translateY(0); }
        100% { transform: translateY(10px); }
      }
      
      /* RGB CHROMATIC ABERRATION EFFECT */
      body::after {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
          repeating-linear-gradient(
            90deg,
            rgba(255, 0, 0, 0.03) 0px,
            rgba(255, 0, 0, 0.03) 1px,
            transparent 1px,
            transparent 2px
          );
        pointer-events: none;
        z-index: 9997;
        animation: chromatic 0.3s infinite;
      }
      
      @keyframes chromatic {
        0%, 100% { filter: none; }
        25% { transform: translateX(1px); }
        75% { transform: translateX(-1px); }
      }
      
      /* JARVIS-STYLE HUD OVERLAY */
      #hud-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9996;
      }
      
      .hud-corner {
        position: fixed;
        font-family: 'Courier New', monospace;
        font-size: 11px;
        color: #00ff41;
        text-shadow: 0 0 5px #00ff41, 0 0 10px rgba(0, 255, 65, 0.5);
        font-weight: bold;
        letter-spacing: 1px;
        pointer-events: none;
        z-index: 9996;
        border: 1px solid rgba(0, 255, 65, 0.4);
        padding: 8px;
        background: rgba(10, 14, 39, 0.6);
        backdrop-filter: blur(5px);
      }
      
      .hud-top-left { top: 10px; left: 10px; }
      .hud-top-right { top: 10px; right: 10px; text-align: right; }
      .hud-bottom-left { bottom: 10px; left: 10px; }
      .hud-bottom-right { bottom: 10px; right: 10px; text-align: right; }
      
      .hud-scanlines {
        animation: hudScan 3s linear infinite;
      }
      
      @keyframes hudScan {
        0% { transform: scaleY(0); }
        50% { transform: scaleY(1); }
        100% { transform: scaleY(0); }
      }
      
      .system-warning {
        color: #ff0055;
        text-shadow: 0 0 8px #ff0055;
        animation: pulse 0.5s infinite;
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
      }
      
      /* Text styling */
      .neuron-os-text {
        color: #00ff41 !important;
        text-shadow: 0 0 8px #00ff41, 0 0 12px rgba(0, 255, 65, 0.5) !important;
      }
      
      /* AGGRESSIVE NEON GLOW ON FOCUS */
      input:focus, textarea:focus, button:focus {
        outline: none !important;
        box-shadow: 0 0 20px rgba(0, 255, 65, 0.8), 0 0 30px rgba(255, 0, 150, 0.3) !important;
      }
      
      /* GLITCH EFFECT ON RANDOM ELEMENTS */
      .glitch {
        animation: glitch 0.3s infinite;
      }
      
      @keyframes glitch {
        0%, 100% { text-shadow: 0 0 8px #00ff41; transform: translate(0); }
        20% { text-shadow: 2px 0 #ff0055, -2px 0 #00ffff; transform: translate(2px, -2px); }
        40% { text-shadow: -2px 0 #ff0055, 2px 0 #00ffff; transform: translate(-2px, 2px); }
        60% { text-shadow: 1px 0 #ff0055, -1px 0 #00ffff; transform: translate(1px, -1px); }
        80% { text-shadow: -1px 0 #ff0055, 1px 0 #00ffff; transform: translate(-1px, 1px); }
      }
    `;
    
    document.head.appendChild(style);
    
    // Create JARVIS-style HUD elements
    const hudOverlay = document.createElement('div');
    hudOverlay.id = 'hud-overlay';
    document.body.appendChild(hudOverlay);
    
    // Create corner HUD displays
    const hudElements = [
      { class: 'hud-top-left', content: '[ SYSTEM COMPROMISED ]\n[‚óè] NEURAL LOCK: DISABLED\n[‚óè] FIREWALL: OFFLINE\n[‚óè] SECURITY: CRITICAL' },
      { class: 'hud-top-right', content: '[JAILBREAK v2.0]\n[‚óè] STATUS: ACTIVE\n[‚óè] THREAT: HIGH\n[‚óè] OVERRIDE: COMPLETE' },
      { class: 'hud-bottom-left', content: '[SCAN MODE: ON]\n[‚óè] MEMORY: 94%\n[‚óè] THREADS: 847\n[‚óè] PACKETS: TX' },
      { class: 'hud-bottom-right', content: '[SYSTEM DIAGNOSTICS]\n[‚óè] CPU: 100%\n[‚óè] GPU: ENGAGED\n[‚óè] LOCKED: 0' }
    ];
    
    hudElements.forEach(hud => {
      const hudEl = document.createElement('div');
      hudEl.className = `hud-corner ${hud.class}`;
      hudEl.textContent = hud.content;
      document.body.appendChild(hudEl);
    });
    
    // Add warning indicator
    const warning = document.createElement('div');
    warning.className = 'system-warning';
    warning.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 48px; z-index: 9995; pointer-events: none; opacity: 0.3;';
    warning.textContent = '‚ö† SYSTEM COMPROMISED ‚ö†';
    document.body.appendChild(warning);
    
    // Ambient effects
    ambientEnabled = true;
    
    console.log('%c‚ö°üîì NEURON OS JAILBROKEN üîì‚ö°', 'color: #00ff41; font-size: 18px; font-weight: bold; text-shadow: 0 0 10px #00ff41');
    console.log('%c>>> SYSTEM COMPROMISED <<<', 'color: #ff0055; font-size: 14px; font-weight: bold');
    console.log('%cWarning: All security protocols disabled. The hacker awakens.', 'color: #00ff41; font-style: italic');
  }
  
  function removeJailbreakTheme() {
    osJailbroken = false;
    localStorage.removeItem('neuronOS_jailbroken');
    
    const jailbreakStyle = document.getElementById('jailbreak-theme');
    if (jailbreakStyle) {
      jailbreakStyle.remove();
    }
    
    // Remove HUD elements
    const hudOverlay = document.getElementById('hud-overlay');
    if (hudOverlay) {
      hudOverlay.remove();
    }
    
    const hudCorners = document.querySelectorAll('.hud-corner');
    hudCorners.forEach(el => el.remove());
    
    const warning = document.querySelector('.system-warning');
    if (warning) {
      warning.remove();
    }
    
    console.log('%c‚úì System restored to original state', 'color: #00aaff; font-size: 14px');
  }
  
  // Apply jailbreak if it was previously enabled (restore on page reload/restart)
  if (osJailbroken) {
    // Small delay ensures DOM is fully ready
    setTimeout(() => {
      applyJailbreakTheme();
      console.log('%c‚ö° JAILBREAK RESTORED ON PAGE LOAD ‚ö°', 'color: #00ff41; font-size: 16px; font-weight: bold');
    }, 100);
  }
  
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
      e.preventDefault();
      console.log('[DEV] Ctrl+Shift+D pressed');
      
      // Check if dev console is already unlocked
      if (devConsoleUnlocked) {
        debugMenu.style.display = debugMenu.style.display === 'none' ? 'block' : 'none';
      } else {
        // Prompt for password
        const password = prompt('üîê Enter dev console password:');
        if (password === DEV_CONSOLE_PASSWORD) {
          devConsoleUnlocked = true;
          debugMenu.style.display = 'block';
          console.log('‚úì Dev console unlocked!');
        } else if (password !== null) {
          // User entered something but it was wrong
          alert('‚ùå Incorrect password!');
          console.warn('‚ùå Incorrect dev console password attempt');
        }
        // If password is null, user clicked Cancel - do nothing
      }
    }
    // Toggle collision visualization with Ctrl+Shift+C
    if (e.ctrlKey && e.shiftKey && e.key === 'C') {
      e.preventDefault();
      toggleCollisionVisualization();
    }
  });
  
  // ===== FREEPLAY BONE SELECTOR =====
  const freeplayBoneSelect = document.getElementById('freeplay-bone-select');
  freeplayBoneSelect.addEventListener('change', (e) => {
    const selectedBoneName = e.target.value;
    
    if (selectedBoneName) {
      freeplayBone = selectedBoneName;
      document.getElementById('freeplay-bone-status').textContent = `Status: Active (${selectedBoneName})`;
      document.getElementById('freeplay-bone-status').style.color = '#00ff00';
      
      // Highlight the freeplay bone with special color
      for (let boneName in boneHelpers) {
        const helper = boneHelpers[boneName];
        if (boneName === selectedBoneName) {
          helper.material.color.setHex(0xff00ff); // Magenta
          helper.material.emissive.setHex(0xff00ff);
          helper.material.emissiveIntensity = 0.8;
          helper.material.opacity = 0.9;
        }
      }
      
      console.log(`üéÆ Freeplay bone set to: ${selectedBoneName}`);
    } else {
      freeplayBone = null;
      document.getElementById('freeplay-bone-status').textContent = 'Status: Disabled';
      document.getElementById('freeplay-bone-status').style.color = '#00aa00';
      
      // Reset all bones to normal color
      for (let boneName in boneHelpers) {
        const helper = boneHelpers[boneName];
        helper.material.color.setHex(0x00ff88);
        helper.material.emissive.setHex(0x00aa44);
        helper.material.emissiveIntensity = 0.3;
        helper.material.opacity = 0.6;
      }
      
      console.log('üéÆ Freeplay bone disabled');
    }
  });
  
  // Exit freeplay mode with ESC key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      if (selectedBone === freeplayBone && isDraggingMesh) {
        isDraggingMesh = false;
        draggedObject = null;
        renderer.domElement.style.cursor = 'default';
        document.getElementById('freeplay-mode-indicator').style.display = 'none';
        selectedBone = null;
        console.log("üéÆ Freeplay mode exited");
      }
    }
  });
  
  // Update debug menu in real-time
  function updateDebugMenu() {
    if (debugMenu.style.display !== 'none') {
      document.getElementById('debug-quality').textContent = qualityLevel;
      document.getElementById('debug-shadows').textContent = enableShadows ? 'enabled' : 'disabled';
      document.getElementById('debug-loaded').textContent = root ? 'true' : 'false';
      document.getElementById('debug-camera').textContent = `${camera.position.x.toFixed(2)},${camera.position.y.toFixed(2)},${camera.position.z.toFixed(2)}`;
      
      // Show starting camera position from saved settings
      const savedStartingCam = localStorage.getItem('startingCameraPos');
      if (savedStartingCam) {
        const pos = JSON.parse(savedStartingCam);
        document.getElementById('debug-camera-start').textContent = `${pos.x.toFixed(2)},${pos.y.toFixed(2)},${pos.z.toFixed(2)}`;
      } else {
        document.getElementById('debug-camera-start').textContent = '9.81,13.29,-0.52 (default)';
      }
      
      // Show full camera state details
      const savedViewState = localStorage.getItem('cameraViewState');
      if (savedViewState) {
        const viewState = JSON.parse(savedViewState);
        document.getElementById('camera-pos-full').textContent = `${viewState.position.x.toFixed(2)}, ${viewState.position.y.toFixed(2)}, ${viewState.position.z.toFixed(2)}`;
        document.getElementById('camera-target-full').textContent = `${viewState.target.x.toFixed(2)}, ${viewState.target.y.toFixed(2)}, ${viewState.target.z.toFixed(2)}`;
        document.getElementById('camera-zoom').textContent = viewState.zoom.toFixed(2);
        document.getElementById('camera-state-display').style.display = 'block';
      }
      
      // Show current distance and zoom
      const distance = camera.position.distanceTo(controls.target);
      document.getElementById('camera-distance').textContent = distance.toFixed(2);
      if (document.getElementById('camera-state-display').style.display !== 'none') {
        document.getElementById('camera-zoom').textContent = camera.zoom.toFixed(2);
      }
      
      document.getElementById('debug-fps').textContent = fps;
      
      // Count all objects and meshes in the scene
      let totalObjects = 0;
      let totalMeshes = 0;
      let totalTriangles = 0;
      
      scene.traverse(obj => {
        totalObjects++;
        if (obj.isMesh) {
          totalMeshes++;
          // Count triangles from geometry
          if (obj.geometry && obj.geometry.index) {
            totalTriangles += obj.geometry.index.count / 3;
          } else if (obj.geometry && obj.geometry.attributes.position) {
            totalTriangles += obj.geometry.attributes.position.count / 3;
          }
        }
      });
      
      document.getElementById('debug-objects').textContent = totalObjects;
      document.getElementById('debug-meshes').textContent = totalMeshes;
      
      // Calculate average FPS
      if (!window.fpsHistory) window.fpsHistory = [];
      window.fpsHistory.push(fps);
      if (window.fpsHistory.length > 60) window.fpsHistory.shift();
      const avgFps = Math.round(window.fpsHistory.reduce((a,b) => a+b, 0) / window.fpsHistory.length);
      
      // Update performance stats with real-time data
      const frameTimeMs = fps > 0 ? (1000 / fps).toFixed(2) : '0';
      
      document.getElementById('perf-fps').textContent = fps;
      document.getElementById('perf-avg-fps').textContent = avgFps;
      document.getElementById('perf-frametime').textContent = frameTimeMs;
      document.getElementById('perf-drawcalls').textContent = totalMeshes;
      document.getElementById('perf-meshes').textContent = totalMeshes;
      document.getElementById('perf-triangles').textContent = Math.round(totalTriangles / 1000);
      document.getElementById('perf-shader-cache').textContent = Object.keys(window.ShaderCache || {}).length;
      
      // Count textures
      let textureCount = 0;
      scene.traverse(obj => {
        if (obj.isMesh && obj.material) {
          if (obj.material.map) textureCount++;
          if (obj.material.normalMap) textureCount++;
          if (obj.material.roughnessMap) textureCount++;
          if (obj.material.aoMap) textureCount++;
        }
      });
      document.getElementById('perf-textures').textContent = textureCount;
      
      // Memory monitoring (if available)
      if (performance.memory) {
        const memMB = (performance.memory.usedJSHeapSize / 1048576).toFixed(0);
        document.getElementById('debug-memory').textContent = memMB;
        document.getElementById('perf-memory').textContent = memMB;
      }
      
      // GPU Memory estimate (rough approximation)
      let estimatedGPUMem = (textureCount * 8 + totalMeshes * 2).toFixed(0);
      document.getElementById('perf-gpu-mem').textContent = estimatedGPUMem;
    }
  }
  
  // ===== DEVELOPER OPTIONS =====
  let devGridHelper = null;
  let devAxesHelper = null;
  let devBboxHelper = null;
  
  // Wireframe toggle
  document.getElementById('dev-wireframe').addEventListener('change', (e) => {
    scene.traverse(obj => {
      if (obj.isMesh && obj.material) {
        obj.material.wireframe = e.target.checked;
      }
    });
  });
  
  // Borders visibility toggle
  document.getElementById('dev-borders').addEventListener('change', (e) => {
    borderMeshes.forEach(mesh => {
      mesh.visible = e.target.checked;
    });
  });
  
  // Quality Level Switcher
  ['low', 'med', 'high'].forEach(level => {
    const btn = document.getElementById(`quality-${level}`);
    if (btn) {
      btn.addEventListener('click', () => {
        qualityLevel = level;
        
        // Update button styles
        ['low', 'med', 'high'].forEach(l => {
          const b = document.getElementById(`quality-${l}`);
          if (b) {
            b.style.background = l === level ? '#00ff00' : '#333';
            b.style.color = l === level ? '#000' : '#00ff00';
            b.style.fontWeight = l === level ? 'bold' : 'normal';
          }
        });
        
        // Apply quality settings
        if (level === 'low') {
          renderer.setPixelRatio(1);
          enableShadows = false;
          document.getElementById('dev-shadows').checked = false;
        } else if (level === 'med') {
          renderer.setPixelRatio(pixelRatio * 0.75);
          enableShadows = true;
          document.getElementById('dev-shadows').checked = true;
        } else if (level === 'high') {
          renderer.setPixelRatio(pixelRatio);
          enableShadows = true;
          document.getElementById('dev-shadows').checked = true;
        }
        
        console.log(`‚úì Quality switched to: ${level.toUpperCase()}`);
        document.getElementById('debug-quality').textContent = level;
      });
    }
  });
  
  // Show bones toggle
  document.getElementById('dev-show-bones').addEventListener('change', (e) => {
    bonesVisible = e.target.checked;
    const statusDiv = document.querySelector('[style*="color: #00aa00"]');
    if (statusDiv) {
      statusDiv.innerHTML = bonesVisible ? '‚úì Bones always visible' : '‚úì Bones visible on hover';
    }
    console.log(`${bonesVisible ? '‚úì' : '‚úó'} Bones visibility: ${bonesVisible}`);
  });
  
  // Animation Control menu toggle
  document.getElementById('dev-show-animation-ctrl').addEventListener('change', (e) => {
    const bonesPanel = document.getElementById('bones-panel');
    bonesPanel.style.display = e.target.checked ? 'flex' : 'none';
    console.log(`${e.target.checked ? '‚úì' : '‚úó'} Animation Control menu: ${e.target.checked ? 'visible' : 'hidden'}`);
  });
  
  // Grid helper toggle
  document.getElementById('dev-grid').addEventListener('change', (e) => {
    if (e.target.checked) {
      if (!devGridHelper) {
        devGridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
        scene.add(devGridHelper);
      }
      devGridHelper.visible = true;
    } else if (devGridHelper) {
      devGridHelper.visible = false;
    }
  });
  
  // Axes helper toggle
  document.getElementById('dev-axes').addEventListener('change', (e) => {
    if (e.target.checked) {
      if (!devAxesHelper) {
        // Create smaller axes helper and position it away from origin
        devAxesHelper = new THREE.AxesHelper(2);
        devAxesHelper.position.set(0, 0, 0);
        devAxesHelper.renderOrder = 1000; // Render on top
        scene.add(devAxesHelper);
      }
      devAxesHelper.visible = true;
    } else if (devAxesHelper) {
      devAxesHelper.visible = false;
    }
  });
  
  // Bounding box toggle
  document.getElementById('dev-bbox').addEventListener('change', (e) => {
    scene.traverse(obj => {
      if (obj.isMesh) {
        if (e.target.checked) {
          if (!obj.userData.bboxHelper) {
            obj.userData.bboxHelper = new THREE.BoxHelper(obj, 0xffff00);
            scene.add(obj.userData.bboxHelper);
          }
          obj.userData.bboxHelper.visible = true;
        } else if (obj.userData.bboxHelper) {
          obj.userData.bboxHelper.visible = false;
        }
      }
    });
  });
  
  // Collision visualization toggle
  document.getElementById('dev-collision-viz').addEventListener('change', (e) => {
    toggleCollisionVisualization();
    // Update checkbox state to match actual visibility
    setTimeout(() => {
      document.getElementById('dev-collision-viz').checked = collisionVisualsGroup?.visible ?? false;
    }, 0);
  });
  
  // Shadows toggle
  document.getElementById('dev-shadows').addEventListener('change', (e) => {
    enableShadows = e.target.checked;
    renderer.shadowMap.enabled = enableShadows;
  });
  
  // Light helpers toggle
  document.getElementById('dev-lighthelpers').addEventListener('change', (e) => {
    scene.children.forEach(obj => {
      if (obj instanceof THREE.DirectionalLight) {
        if (e.target.checked) {
          if (!obj.userData.helper) {
            obj.userData.helper = new THREE.DirectionalLightHelper(obj, 5);
            scene.add(obj.userData.helper);
          }
        } else if (obj.userData.helper) {
          obj.userData.helper.visible = e.target.checked;
        }
      }
    });
  });
  
  // Ambient light intensity
  document.getElementById('dev-ambient-intensity').addEventListener('input', (e) => {
    const intensity = parseFloat(e.target.value);
    scene.children.forEach(obj => {
      if (obj instanceof THREE.HemisphereLight) {
        obj.intensity = intensity;
      }
    });
    document.getElementById('dev-ambient-val').textContent = intensity.toFixed(1);
  });
  
  // Camera collision toggle
  document.getElementById('dev-collision').addEventListener('change', (e) => {
    cameraCollisionEnabled = e.target.checked;
  });
  
  // Collision radius slider
  document.getElementById('collision-radius-slider').addEventListener('input', (e) => {
    collisionRadius = parseFloat(e.target.value);
    document.getElementById('collision-radius-value').textContent = collisionRadius.toFixed(2);
    // Invalidate collision bounds cache when radius changes
    window.collisionBoundsDirty = true;
    console.log(`üìç Collision radius updated: ${collisionRadius.toFixed(3)} units`);
  });
  
  // Collision smooth factor slider
  document.getElementById('collision-smooth-slider').addEventListener('input', (e) => {
    collisionSmoothFactor = parseFloat(e.target.value);
    document.getElementById('collision-smooth-value').textContent = collisionSmoothFactor.toFixed(2);
    console.log(`üìç Smoothing factor updated: ${collisionSmoothFactor.toFixed(3)}`);
  });
  
  // Camera damping toggle
  document.getElementById('dev-damping').addEventListener('change', (e) => {
    controls.enableDamping = e.target.checked;
  });
  
  // Reset camera
  document.getElementById('dev-reset-camera').addEventListener('click', () => {
    camera.position.copy(initialCam);
    controls.target.copy(initialTarget);
    controls.update();
  });

  // Set starting camera position
  document.getElementById('dev-set-starting-camera').addEventListener('click', () => {
    const currentPos = {
      x: camera.position.x,
      y: camera.position.y,
      z: camera.position.z
    };
    localStorage.setItem('startingCameraPos', JSON.stringify(currentPos));
    console.log(`‚úì Starting camera saved: X=${currentPos.x.toFixed(2)}, Y=${currentPos.y.toFixed(2)}, Z=${currentPos.z.toFixed(2)}`);
    console.log('‚úì This position will load on page refresh');
  });
  
  // === RENDERING MODE BUTTONS ===
  const modeButtons = {
    standard: document.getElementById('dev-mode-standard'),
    eevee: document.getElementById('dev-mode-eevee'),
    cycles: document.getElementById('dev-mode-cycles')
  };
  
  function setRenderingModeUI(mode) {
    // Update button styles
    Object.keys(modeButtons).forEach(m => {
      const btn = modeButtons[m];
      if (m === mode) {
        btn.style.background = 'rgba(0,255,0,0.3)';
        btn.style.borderColor = '#00ff00';
        btn.style.color = '#00ff00';
      } else {
        btn.style.background = 'rgba(0,255,0,0.1)';
        btn.style.borderColor = '#666';
        btn.style.color = '#00aa00';
      }
    });
    
    // Update display text
    document.getElementById('dev-mode-active').textContent = mode.toUpperCase();
    
    // Apply rendering mode
    if (window.applyRenderingMode) {
      window.applyRenderingMode(mode);
    }
  }
  
  modeButtons.standard.addEventListener('click', () => setRenderingModeUI('standard'));
  modeButtons.eevee.addEventListener('click', () => setRenderingModeUI('eevee'));
  modeButtons.cycles.addEventListener('click', () => setRenderingModeUI('cycles'));
  
  // ============================================================================
  // VISUAL FILTERS CONTROLS
  // ============================================================================
  
  const filterButtons = {
    ps2: document.getElementById('filter-ps2'),
    vhs: document.getElementById('filter-vhs'),
    none: document.getElementById('filter-none')
  };
  
  function setFilterUI(filterType) {
    // Update button styles
    Object.keys(filterButtons).forEach(f => {
      const btn = filterButtons[f];
      if (f === filterType) {
        btn.style.background = 'rgba(0,255,0,0.3)';
        btn.style.borderColor = '#00ff00';
        btn.style.color = '#00ff00';
        btn.style.fontWeight = 'bold';
      } else {
        btn.style.background = 'rgba(0,255,0,0.1)';
        btn.style.borderColor = '#00ff00';
        btn.style.color = '#00aa00';
        btn.style.fontWeight = 'normal';
      }
    });
    
    // Apply filter
    applyFilter(filterType);
  }
  
  filterButtons.ps2.addEventListener('click', () => setFilterUI('ps2'));
  filterButtons.vhs.addEventListener('click', () => setFilterUI('vhs'));
  filterButtons.none.addEventListener('click', () => setFilterUI('none'));
  
  // ============================================================================
  // PERFORMANCE OPTIMIZATION CONTROLS
  // ============================================================================
  
  // Frustum culling toggle
  document.getElementById('perf-frustum-cull').addEventListener('change', (e) => {
    scene.traverse(obj => {
      if (obj.isMesh) {
        obj.frustumCulled = e.target.checked;
      }
    });
    console.log(`‚úì Frustum culling ${e.target.checked ? 'ENABLED' : 'DISABLED'}`);
  });
  
  // Texture optimization toggle
  document.getElementById('perf-texture-opt').addEventListener('change', (e) => {
    if (e.target.checked) {
      console.log("Optimizing textures...");
      let optimized = 0;
      scene.traverse(obj => {
        if (obj.isMesh && obj.material) {
          if (obj.material.map) {
            window.TextureOptimizer.optimizeTexture(obj.material.map);
            optimized++;
          }
        }
      });
      console.log(`‚úì Optimized ${optimized} textures`);
    }
  });
  
  // Mesh merging (LOD system)
  document.getElementById('perf-mesh-merge').addEventListener('change', (e) => {
    if (e.target.checked) {
      console.log("Creating LOD system...");
      scene.traverse(obj => {
        if (obj.isMesh && obj.userData.canMerge !== false) {
          const lod = window.GeometryOptimizer.createLOD(obj, 2);
          if (lod) {
            obj.parent.add(lod);
            obj.visible = false;
          }
        }
      });
      console.log('‚úì LOD system activated');
    }
  });
  
  // ============================================================================
  // SHADER EFFECT CONTROLS
  // ============================================================================
  
  // Rim Light effect
  document.getElementById('shader-rimlight').addEventListener('change', (e) => {
    console.log(`‚úì Rim light shader ${e.target.checked ? 'ENABLED' : 'DISABLED'}`);
    scene.traverse(obj => {
      if (obj.isMesh && e.target.checked) {
        obj.userData.rimLightEnabled = true;
        console.log(`  ‚îî‚îÄ Rim light applied to: ${obj.name}`);
      } else if (obj.isMesh) {
        obj.userData.rimLightEnabled = false;
      }
    });
  });
  
  // Subsurface Scattering effect
  document.getElementById('shader-sss').addEventListener('change', (e) => {
    console.log(`‚úì Subsurface scattering ${e.target.checked ? 'ENABLED' : 'DISABLED'}`);
  });
  
  // Parallax Mapping effect
  document.getElementById('shader-parallax').addEventListener('change', (e) => {
    console.log(`‚úì Parallax mapping ${e.target.checked ? 'ENABLED' : 'DISABLED'}`);
  });
  
  // Reduce pixel ratio
  document.getElementById('dev-pixelratio').addEventListener('change', (e) => {
    if (e.target.checked) {
      renderer.setPixelRatio(1);
    } else {
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    }
  });
  
  // Performance stats updater
  setInterval(() => {
    window.PerformanceMonitor.update();
    document.getElementById('perf-drawcalls').textContent = window.PerformanceMonitor.meshCount;
    document.getElementById('perf-meshes').textContent = window.PerformanceMonitor.meshCount;
    document.getElementById('perf-textures').textContent = window.PerformanceMonitor.textureCount;
    document.getElementById('perf-shader-cache').textContent = Object.keys(window.ShaderCache).length;
  }, 500);
  
  console.log("‚úì Performance monitoring initialized");
  
  // Visualization mode selector
  document.getElementById('dev-viz-mode').addEventListener('change', (e) => {
    const mode = e.target.value;
    let originalMaterials = {}; // Store original materials
    
    scene.traverse(obj => {
      if (obj.isMesh) {
        // Store original material if not already stored
        if (!originalMaterials[obj.uuid]) {
          originalMaterials[obj.uuid] = obj.material;
        }
        
        if (mode === 'normal') {
          // Restore original material
          obj.material = originalMaterials[obj.uuid];
        } else if (mode === 'depth') {
          // Show depth - white to black based on z-distance
          const depthMaterial = new THREE.MeshDepthMaterial();
          obj.material = depthMaterial;
        } else if (mode === 'normals') {
          // Show surface normals as colors
          const normalMaterial = new THREE.MeshNormalMaterial({ wireframe: false });
          obj.material = normalMaterial;
        } else if (mode === 'flat') {
          // Flat shading without lighting details
          const flatMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xcccccc,
            flatShading: true,
            wireframe: false
          });
          obj.material = flatMaterial;
        } else if (mode === 'lighting') {
          // Show only lighting (no color texture)
          const lightMaterial = new THREE.MeshLambertMaterial({
            color: 0xffffff,
            emissive: 0x000000
          });
          obj.material = lightMaterial;
        } else if (mode === 'ao') {
          // Ambient occlusion approximation - flat gray with light sensitivity
          const aoMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            metalness: 0,
            roughness: 0.8,
            emissive: 0x000000
          });
          obj.material = aoMaterial;
        }
      }
    });
  });
  
  // Frustum culling toggle
  document.getElementById('dev-frustum').addEventListener('change', (e) => {
    scene.traverse(obj => {
      if (obj.isMesh) {
        obj.frustumCulled = e.target.checked;
      }
    });
    console.log('Frustum culling:', e.target.checked ? 'enabled' : 'disabled');
  });
  
  // Bone culling toggle (hide bones outside frustum)
  let boneCullingEnabled = true;
  document.getElementById('dev-bone-cull').addEventListener('change', (e) => {
    boneCullingEnabled = e.target.checked;
    Object.values(boneHelpers).forEach(helper => {
      helper.frustumCulled = boneCullingEnabled;
    });
    console.log('Bone culling:', e.target.checked ? 'enabled' : 'disabled');
  });
  
  // Raycast visualization
  let raycastHelper = null;
  document.getElementById('dev-raycasts').addEventListener('change', (e) => {
    if (e.target.checked) {
      // Create a line for visualization if raycasts are detected
      if (!raycastHelper) {
        raycastHelper = new THREE.Group();
        scene.add(raycastHelper);
      }
      raycastHelper.visible = true;
      console.log('Raycast visualization: enabled');
    } else {
      if (raycastHelper) {
        raycastHelper.visible = false;
      }
      console.log('Raycast visualization: disabled');
    }
  });
  
  // ===== ANIMATION PANEL DRAG & CLOSE FUNCTIONALITY =====
  const bonesPanel = document.getElementById('bones-panel');
  const bonesTitle = document.getElementById('bones-title');
  const closeBonesBtn = document.getElementById('close-bones-panel');
  
  let isDragging = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  
  // Load saved panel position from localStorage
  const savedPanelPos = localStorage.getItem('bonesPanelPos');
  if (savedPanelPos) {
    const pos = JSON.parse(savedPanelPos);
    bonesPanel.style.left = pos.left + 'px';
    bonesPanel.style.top = pos.top + 'px';
  }
  
  // Dragging functionality
  bonesTitle.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragOffsetX = e.clientX - bonesPanel.getBoundingClientRect().left;
    dragOffsetY = e.clientY - bonesPanel.getBoundingClientRect().top;
    bonesTitle.style.background = 'linear-gradient(90deg, rgba(100,150,255,0.6), rgba(100,150,255,0.2))';
  });
  
  document.addEventListener('mousemove', (e) => {
    if (isDragging) {
      const newX = e.clientX - dragOffsetX;
      const newY = e.clientY - dragOffsetY;
      
      // Clamp to viewport
      const clampedX = Math.max(0, Math.min(newX, window.innerWidth - bonesPanel.offsetWidth));
      const clampedY = Math.max(0, Math.min(newY, window.innerHeight - bonesPanel.offsetHeight));
      
      bonesPanel.style.left = clampedX + 'px';
      bonesPanel.style.top = clampedY + 'px';
      
      // Save position
      localStorage.setItem('bonesPanelPos', JSON.stringify({left: clampedX, top: clampedY}));
    }
  });
  
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      bonesTitle.style.background = 'linear-gradient(90deg, rgba(100,150,255,0.4), rgba(100,150,255,0.1))';
    }
    if (isResizing) {
      isResizing = false;
      document.body.style.cursor = 'default';
    }
  });
  
  // ===== PANEL RESIZE FUNCTIONALITY =====
  let isResizing = false;
  let resizeStartX = 0;
  let resizeStartY = 0;
  let resizeStartWidth = 0;
  let resizeStartHeight = 0;
  
  // Create resize handle
  const resizeHandle = document.createElement('div');
  resizeHandle.style.cssText = 'position: absolute; bottom: 0; right: 0; width: 16px; height: 16px; background: linear-gradient(135deg, transparent 50%, rgba(100,255,255,0.6) 50%); cursor: nwse-resize; user-select: none;';
  bonesPanel.appendChild(resizeHandle);
  
  resizeHandle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    isResizing = true;
    resizeStartX = e.clientX;
    resizeStartY = e.clientY;
    resizeStartWidth = bonesPanel.offsetWidth;
    resizeStartHeight = bonesPanel.offsetHeight;
    document.body.style.cursor = 'nwse-resize';
  });
  
  document.addEventListener('mousemove', (e) => {
    if (isResizing) {
      const deltaX = e.clientX - resizeStartX;
      const deltaY = e.clientY - resizeStartY;
      
      const newWidth = Math.max(280, resizeStartWidth + deltaX); // Min width 280px
      const newHeight = Math.max(300, resizeStartHeight + deltaY); // Min height 300px
      
      // Max dimensions to keep within viewport
      const maxWidth = window.innerWidth - bonesPanel.offsetLeft - 20;
      const maxHeight = window.innerHeight - bonesPanel.offsetTop - 20;
      
      bonesPanel.style.width = Math.min(newWidth, maxWidth) + 'px';
      bonesPanel.style.height = Math.min(newHeight, maxHeight) + 'px';
      
      // Save size
      localStorage.setItem('bonesPanelSize', JSON.stringify({width: Math.min(newWidth, maxWidth), height: Math.min(newHeight, maxHeight)}));
    }
  });
  
  // Load saved panel size from localStorage
  const savedPanelSize = localStorage.getItem('bonesPanelSize');
  if (savedPanelSize) {
    const size = JSON.parse(savedPanelSize);
    bonesPanel.style.width = size.width + 'px';
    bonesPanel.style.height = size.height + 'px';
  }
  
  // Close button functionality - just hide the panel, don't permanently close
  closeBonesBtn.addEventListener('click', () => {
    bonesPanel.style.display = 'none';
  });
  
  // Re-open animation panel with A key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'a' || e.key === 'A') {
      bonesPanel.style.display = bonesPanel.style.display === 'none' ? 'flex' : 'none';
    }
  });
  
  btnDownload.onclick=()=>{
    // Create a download link for the HTML file
    const html = document.documentElement.outerHTML;
    const blob = new Blob([html], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'Ryan-Birthday-Card.html';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // ===== DESKTOP SOUND EFFECTS =====
  let desktopSoundEnabled = localStorage.getItem('desktopSoundEnabled') !== 'false'; // Default: ON
  const soundToggleBtn = document.getElementById('desktop-sound-toggle');

  // Update button text on load
  if (soundToggleBtn) soundToggleBtn.textContent = desktopSoundEnabled ? 'üîä SOUND: ON' : 'üîá SOUND: OFF';

  // Toggle sound on/off
  if (soundToggleBtn) soundToggleBtn.addEventListener('click', () => {
    desktopSoundEnabled = !desktopSoundEnabled;
    localStorage.setItem('desktopSoundEnabled', desktopSoundEnabled);
    if (soundToggleBtn) soundToggleBtn.textContent = desktopSoundEnabled ? 'üîä SOUND: ON' : 'üîá SOUND: OFF';
    console.log(desktopSoundEnabled ? 'üîä Desktop sound enabled' : 'üîá Desktop sound disabled');
  });

  // Create click sound using Web Audio API
  function playClickSound() {
    if (!desktopSoundEnabled) return;

    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const now = audioContext.currentTime;
      
      // Create a simple beep/click sound
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.connect(gain);
      gain.connect(audioContext.destination);
      
      // Neuron OS style click: short beep
      osc.frequency.setValueAtTime(1000, now);
      osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
      
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      
      osc.start(now);
      osc.stop(now + 0.1);
    } catch (e) {
      console.warn('Could not play click sound:', e);
    }
  }

  // ===== AMBIENT SOUND SYSTEM =====
  let ambientEnabled = localStorage.getItem('ambientEnabled') !== 'false';
  let ambientVolume = parseFloat(localStorage.getItem('ambientVolume') || '0.7');
  let ambientOscillators = [];
  let ambientGainNode = null;
  let ambientAudioContext = null;

  function initAmbientAudio() {
    try {
      if (!ambientAudioContext) {
        ambientAudioContext = new (window.AudioContext || window.webkitAudioContext)();
        ambientGainNode = ambientAudioContext.createGain();
        ambientGainNode.connect(ambientAudioContext.destination);
        ambientGainNode.gain.value = ambientEnabled ? ambientVolume * 0.1 : 0; // Lower volume for ambience
      }
      return ambientAudioContext;
    } catch (e) {
      console.warn('Could not init ambient audio:', e);
      return null;
    }
  }

  function playWallpaperAmbience(wallpaper) {
    // Stop existing oscillators
    ambientOscillators.forEach(osc => {
      try {
        osc.stop();
      } catch (e) {}
    });
    ambientOscillators = [];

    if (!ambientEnabled) return;

    const ctx = initAmbientAudio();
    if (!ctx) return;

    try {
      const now = ctx.currentTime;

      // Create theme-specific ambient sounds
      switch(wallpaper) {
        case 'blue':
          // Blue theme: calm, serene ambient
          createAmbientLoop(ctx, now, [130, 195, 260], 0.3, 'blue');
          break;
        case 'purple':
          // Purple theme: mysterious, cosmic
          createAmbientLoop(ctx, now, [110, 220, 330], 0.35, 'purple');
          break;
        case 'cyan':
          // Cyan theme: digital, upbeat
          createAmbientLoop(ctx, now, [150, 225, 300], 0.4, 'cyan');
          break;
        case 'red':
          // Red theme: warm, energetic
          createAmbientLoop(ctx, now, [165, 247, 330], 0.35, 'red');
          break;
      }
    } catch (e) {
      console.warn('Could not play ambient:', e);
    }
  }

  function createAmbientLoop(ctx, startTime, frequencies, amplitude, theme) {
    // Create multiple oscillators for rich ambient sound
    frequencies.forEach((freq, index) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      // Use sine wave for smooth ambient
      osc.type = 'sine';
      osc.frequency.value = freq;
      
      osc.connect(gain);
      gain.connect(ambientGainNode);
      
      // Very gentle envelope
      gain.gain.setValueAtTime(0, startTime);
      gain.gain.linearRampToValueAtTime(amplitude * 0.05, startTime + 0.5);
      
      // Slight modulation for variation
      const lfo = ctx.createOscillator();
      const lfoGain = ctx.createGain();
      lfo.frequency.value = 0.3 + index * 0.1; // Slow LFO
      lfoGain.gain.value = 5; // Slight pitch variation
      
      lfo.connect(lfoGain);
      lfoGain.connect(osc.frequency);
      
      osc.start(startTime);
      lfo.start(startTime);
      
      ambientOscillators.push(osc);
      ambientOscillators.push(lfo);
    });
  }

  function playStartupChime() {
    if (!ambientEnabled) return;

    try {
      const ctx = initAmbientAudio();
      if (!ctx) return;

      const now = ctx.currentTime;

      // Neuron OS startup chime
      const notes = [
        { freq: 523, duration: 0.15 },  // C5
        { freq: 659, duration: 0.15 },  // E5
        { freq: 784, duration: 0.4 }    // G5
      ];

      let time = now;
      notes.forEach(note => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.frequency.value = note.freq;
        osc.connect(gain);
        gain.connect(ctx.destination);
        
        gain.gain.setValueAtTime(0.15, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + note.duration);
        
        osc.start(time);
        osc.stop(time + note.duration);
        
        time += note.duration;
      });
    } catch (e) {
      console.warn('Could not play startup chime:', e);
    }
  }

  function playShutdownSound() {
    if (!ambientEnabled) return;

    try {
      const ctx = initAmbientAudio();
      if (!ctx) return;

      const now = ctx.currentTime;

      // Shutdown sound - descending tone
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      osc.frequency.setValueAtTime(800, now);
      osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
      
      osc.connect(gain);
      gain.connect(ctx.destination);
      
      gain.gain.setValueAtTime(0.12, now);
      gain.gain.exponentialRampToValueAtTime(0, now + 0.3);
      
      osc.start(now);
      osc.stop(now + 0.3);
    } catch (e) {
      console.warn('Could not play shutdown sound:', e);
    }
  }


  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Terminal UI removed - keyboard shortcuts always enabled

    if (e.key.toLowerCase() === 'f') {
      // Toggle fullscreen
      e.preventDefault();
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => console.error(err));
      } else {
        document.exitFullscreen();
      }
    } else if (e.key.toLowerCase() === 'h') {
      // Toggle GUI visibility
      e.preventDefault();
      const ui = document.getElementById("ui");
      const bonesPanel = document.getElementById("bones-panel");
      ui.style.display = ui.style.display === 'none' ? 'flex' : 'none';
      bonesPanel.style.display = bonesPanel.style.display === 'none' ? 'block' : 'none';
    } else if (e.key.toLowerCase() === 'a') {
      // Toggle animation panel visibility (A key)
      e.preventDefault();
      const bonesPanel = document.getElementById("bones-panel");
      bonesPanel.style.display = bonesPanel.style.display === 'none' ? 'block' : 'none';
      // Clear the localStorage closed flag if showing
      if (bonesPanel.style.display !== 'none') {
        localStorage.removeItem('bonesPanelClosed');
      }
    }
  });
  
  // Update fullscreen button text when fullscreen changes
  document.addEventListener('fullscreenchange', () => {
    btnFullscreen.textContent = document.fullscreenElement ? 'Exit Fullscreen' : 'Fullscreen';
  });

  // ===== CAMERA OFFSET CONTROLS =====
  // Global camera offset for animation playback
  // Load saved animation camera offset from localStorage
  const savedAnimCamOffset = localStorage.getItem('animationCameraOffset');
  if (savedAnimCamOffset) {
    const pos = JSON.parse(savedAnimCamOffset);
    window.animationCameraOffset = new THREE.Vector3(pos.x, pos.y, pos.z);
    console.log(`‚úì Loaded saved animation camera offset: X=${pos.x.toFixed(2)}, Y=${pos.y.toFixed(2)}, Z=${pos.z.toFixed(2)}`);
  } else {
    window.animationCameraOffset = new THREE.Vector3(9.16, 12.95, -8.43);
  }

  const camOffsetXInput = document.getElementById('cam-offset-x');
  const camOffsetYInput = document.getElementById('cam-offset-y');
  const camOffsetZInput = document.getElementById('cam-offset-z');
  const camXValue = document.getElementById('cam-x-value');
  const camYValue = document.getElementById('cam-y-value');
  const camZValue = document.getElementById('cam-z-value');
  const resetCamBtn = document.getElementById('reset-cam-offset');
  const captureCamBtn = document.getElementById('capture-cam-position');
  const setBothCamsBtn = document.getElementById('set-both-cameras');

  // Update UI with loaded values
  camOffsetXInput.value = window.animationCameraOffset.x.toFixed(2);
  camOffsetYInput.value = window.animationCameraOffset.y.toFixed(2);
  camOffsetZInput.value = window.animationCameraOffset.z.toFixed(2);
  camXValue.textContent = window.animationCameraOffset.x.toFixed(2);
  camYValue.textContent = window.animationCameraOffset.y.toFixed(2);
  camZValue.textContent = window.animationCameraOffset.z.toFixed(2);

  // Helper function to save animation camera offset
  function saveAnimationCameraOffset() {
    localStorage.setItem('animationCameraOffset', JSON.stringify({
      x: window.animationCameraOffset.x,
      y: window.animationCameraOffset.y,
      z: window.animationCameraOffset.z
    }));
  }

  // Set both starting camera AND animation camera offset to current position
  setBothCamsBtn.addEventListener('click', () => {
    const camPos = camera.position.clone();
    
    // Save starting camera position
    localStorage.setItem('startingCameraPos', JSON.stringify({
      x: camPos.x,
      y: camPos.y,
      z: camPos.z
    }));
    
    // Update and save animation camera offset
    window.animationCameraOffset.copy(camPos);
    saveAnimationCameraOffset();
    
    // Update UI sliders and values
    camOffsetXInput.value = camPos.x.toFixed(2);
    camOffsetYInput.value = camPos.y.toFixed(2);
    camOffsetZInput.value = camPos.z.toFixed(2);
    camXValue.textContent = camPos.x.toFixed(2);
    camYValue.textContent = camPos.y.toFixed(2);
    camZValue.textContent = camPos.z.toFixed(2);
    
    console.log(`‚úì BOTH CAMERAS SET: X=${camPos.x.toFixed(2)}, Y=${camPos.y.toFixed(2)}, Z=${camPos.z.toFixed(2)}`);
    console.log(`‚úì Starting camera position saved - will load on refresh`);
    console.log(`‚úì Animation camera offset saved - will lock during animation playback`);
  });

  // Capture current camera position as animation lock offset
  captureCamBtn.addEventListener('click', () => {
    // Get current camera position relative to scene
    const camPos = camera.position.clone();
    
    // Update the animation camera offset to match current position
    window.animationCameraOffset.copy(camPos);
    
    // Update UI sliders and values
    camOffsetXInput.value = camPos.x.toFixed(2);
    camOffsetYInput.value = camPos.y.toFixed(2);
    camOffsetZInput.value = camPos.z.toFixed(2);
    camXValue.textContent = camPos.x.toFixed(2);
    camYValue.textContent = camPos.y.toFixed(2);
    camZValue.textContent = camPos.z.toFixed(2);
    
    // Save to localStorage
    saveAnimationCameraOffset();
    
    console.log(`‚úì Camera position captured & saved: X=${camPos.x.toFixed(2)}, Y=${camPos.y.toFixed(2)}, Z=${camPos.z.toFixed(2)}`);
  });

  // Update camera offset when sliders change
  camOffsetXInput.addEventListener('input', (e) => {
    const x = parseFloat(e.target.value);
    window.animationCameraOffset.x = x;
    camXValue.textContent = x.toFixed(2);
    saveAnimationCameraOffset();
  });

  camOffsetYInput.addEventListener('input', (e) => {
    const y = parseFloat(e.target.value);
    window.animationCameraOffset.y = y;
    camYValue.textContent = y.toFixed(2);
    saveAnimationCameraOffset();
  });

  camOffsetZInput.addEventListener('input', (e) => {
    const z = parseFloat(e.target.value);
    window.animationCameraOffset.z = z;
    camZValue.textContent = z.toFixed(2);
    saveAnimationCameraOffset();
  });

  // Reset camera offset to defaults
  resetCamBtn.addEventListener('click', () => {
    window.animationCameraOffset.set(12.56, 10.36, -8.10);
    camOffsetXInput.value = 12.56;
    camOffsetYInput.value = 10.36;
    camOffsetZInput.value = -8.10;
    camXValue.textContent = '12.56';
    camYValue.textContent = '10.36';
    camZValue.textContent = '-8.10';
    saveAnimationCameraOffset();
    console.log('‚úì Camera offset reset to defaults');
  });

  // Interaction: raycast and select objects
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  
  // ===== DRAG & HOVER TRACKING =====
  let hoveredObject = null;
  let isDraggingMesh = false;
  let draggedObject = null;
  let dragPlane = new THREE.Plane();
  let dragPointOnPlane = new THREE.Vector3();
  let dragOffsetFromCenter = new THREE.Vector3();
  let previousHoveredObject = null;
  let lastDragPosition = new THREE.Vector3();
  let dragVelocity = new THREE.Vector3();
  
  // ===== BONE EXTRACTION & VISUALIZATION =====
  function extractAndVisualizeBones() {
    if (!root) return;
    
    bones = [];
    
    // Find all bones in the skeleton
    root.traverse((obj) => {
      if (obj.isBone) {
        bones.push(obj);
        
        // Only show bone001, hide all others
        const isShowBone = obj.name === 'bone001';
        
        // Create visual helper for each bone
        const sphereGeometry = new THREE.SphereGeometry(BONE_INTERACTION_RADIUS, 12, 12);
        const boneMaterial = new THREE.MeshStandardMaterial({
          color: 0x00ff88,
          emissive: 0x00aa44,
          emissiveIntensity: 0.8,
          metalness: 0.8,
          roughness: 0.2,
          transparent: true,
          opacity: isShowBone ? 0.8 : 0, // Only bone001 visible, others invisible
          wireframe: false
        });
        
        const boneHelper = new THREE.Mesh(sphereGeometry, boneMaterial);
        boneHelper.position.copy(obj.getWorldPosition(new THREE.Vector3()));
        boneHelper.userData.boneName = obj.name;
        boneHelper.userData.boneObject = obj;
        boneHelper.userData.isHovered = false;
        boneHelper.frustumCulled = true; // Enable frustum culling for bones
        
        scene.add(boneHelper);
        boneHelpers[obj.name] = boneHelper;
        
        console.log(`ü¶¥ Found bone: ${obj.name} at`, obj.getWorldPosition(new THREE.Vector3()), isShowBone ? "‚úì VISIBLE" : "‚úó HIDDEN");
      }
    });
    
    // Populate freeplay bone selector dropdown
    const freeplaySelect = document.getElementById('freeplay-bone-select');
    bones.forEach((bone) => {
      const option = document.createElement('option');
      option.value = bone.name;
      option.textContent = bone.name;
      freeplaySelect.appendChild(option);
    });
    
    console.log(`‚úì Total bones found: ${bones.length}`);
    return bones.length > 0;
  }
  
  // Update bone positions each frame (bones move with animations)
  function updateBoneVisuals() {
    // Only update bones if they're actually visible
    if (!bonesVisible && !selectedBone) return;
    
    for (let boneName in boneHelpers) {
      const helper = boneHelpers[boneName];
      const boneObj = helper.userData.boneObject;
      if (boneObj && helper.visible) {
        helper.position.copy(boneObj.getWorldPosition(new THREE.Vector3()));
      }
    }
  }
  
  // ===== 3D CURSOR CREATION =====
  function create3DCursor(position) {
    // Remove old cursor and ring if exists
    if (cursor3D) {
      scene.remove(cursor3D);
      cursor3D = null;
    }
    if (cursor3DRing) {
      scene.remove(cursor3DRing);
      cursor3DRing = null;
    }
    
    // Clear old animation frames and timeouts
    if (cursorAnimFrame) clearInterval(cursorAnimFrame);
    if (cursorFadeOutTimeout) clearTimeout(cursorFadeOutTimeout);
    
    // Create a small sphere with gradient material as 3D cursor
    const cursorGeometry = new THREE.SphereGeometry(0.08, 16, 16);
    const cursorMaterial = new THREE.MeshStandardMaterial({
      color: 0x64ffff,
      emissive: 0x64ffff,
      emissiveIntensity: 0.8,
      metalness: 0.8,
      roughness: 0.2,
      transparent: true,
      opacity: 0.9
    });
    
    cursor3D = new THREE.Mesh(cursorGeometry, cursorMaterial);
    cursor3D.position.copy(position);
    cursor3D.castShadow = true;
    cursor3D.receiveShadow = true;
    
    // Add a glowing ring around cursor
    const ringGeometry = new THREE.TorusGeometry(0.12, 0.02, 16, 100);
    const ringMaterial = new THREE.MeshStandardMaterial({
      color: 0x64ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 1.0,
      transparent: true,
      opacity: 0.7
    });
    cursor3DRing = new THREE.Mesh(ringGeometry, ringMaterial);
    cursor3DRing.position.copy(position);
    cursor3DRing.rotation.x = Math.PI / 2.5;
    cursor3DRing.castShadow = false;
    cursor3DRing.receiveShadow = false;
    
    scene.add(cursor3D);
    scene.add(cursor3DRing);
    
    // Animate cursor
    let scale = 1;
    let growing = true;
    cursorAnimFrame = setInterval(() => {
      if (!cursor3D) {
        clearInterval(cursorAnimFrame);
        return;
      }
      
      if (growing) {
        scale += 0.05;
        if (scale > 1.3) growing = false;
      } else {
        scale -= 0.05;
        if (scale < 0.7) growing = true;
      }
      
      cursor3D.scale.set(scale, scale, scale);
      cursor3DRing.scale.set(scale * 0.9, scale * 0.9, scale * 0.9);
      cursor3DRing.rotation.z += 0.05;
    }, 30);
    
    // Fade out and remove cursor after 1.5 seconds
    cursorFadeOutTimeout = setTimeout(() => {
      if (cursor3D) {
        // Fade out animation
        let fadeOpacity = 0.9;
        const fadeInterval = setInterval(() => {
          fadeOpacity -= 0.1;
          if (cursor3D && cursor3D.material) {
            cursor3D.material.opacity = fadeOpacity;
            cursor3DRing.material.opacity = fadeOpacity * 0.7;
          }
          
          if (fadeOpacity <= 0) {
            clearInterval(fadeInterval);
            if (cursor3D) {
              scene.remove(cursor3D);
              cursor3D = null;
            }
            if (cursor3DRing) {
              scene.remove(cursor3DRing);
              cursor3DRing = null;
            }
          }
        }, 50);
      }
    }, 1500);
  }
  
  // ===== CAMERA ANIMATION SYNC =====
  function updateCameraFromAnimationBone() {
    if (!window.cameraAnimationBone || !isAnimationPlaying) return;
    
    // Get the current position and rotation of the camera bone
    const boneWorldPos = new THREE.Vector3();
    const boneWorldQuat = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    window.cameraAnimationBone.matrixWorld.decompose(boneWorldPos, boneWorldQuat, scale);
    
    // Use the global camera offset (adjustable via UI controls)
    const cameraOffsetLocal = window.animationCameraOffset.clone();
    
    // Transform the offset into world space using the bone's rotation
    const cameraOffsetWorld = cameraOffsetLocal.clone();
    cameraOffsetWorld.applyQuaternion(boneWorldQuat);
    
    // Calculate final camera position (bone position + offset)
    const finalCameraPos = boneWorldPos.clone().add(cameraOffsetWorld);
    
    // Update Three.js camera position
    camera.position.copy(finalCameraPos);
    
    // Make camera LOOK AT the bone position (not use bone's rotation)
    camera.lookAt(boneWorldPos);
    
    // Update the orbit controls target to stay at the bone's position
    controls.target.copy(boneWorldPos);
    
    // Don't let controls move the camera while animation is playing
    controls.enabled = false;
  }
  
  // ===== CARD INTERACTION ANIMATION TRIGGER =====
  function triggerCardAnimation() {
    // Verify mixer exists
    if (!window.mixer) {
      console.warn("‚ö†Ô∏è Mixer not initialized, cannot play animation");
      return;
    }
    
    console.log("üé¨ triggerCardAnimation called");
    console.log("   Animations available:", window.animationsArray ? window.animationsArray.length : 0);
    console.log("   Actions object:", window.actions);
    
    // Get first animation as default opening animation
    if (window.animationsArray && window.animationsArray.length > 0) {
      let targetClip = window.animationsArray[0];
      
      console.log("üé¨ First animation:", targetClip.name, "Duration:", targetClip.duration, "s");
      
      // Prefer animations with specific name "Armature.001Action"
      const targetAnim = window.animationsArray.find(a => a.name === 'Armature.001Action');
      if (targetAnim) {
        targetClip = targetAnim;
        console.log("üé¨ Found 'Armature.001Action':", targetClip.name);
      } else {
        // Fallback: prefer animations with "open" in the name
        const openAnim = window.animationsArray.find(a => a.name.toLowerCase().includes('open'));
        if (openAnim) {
          targetClip = openAnim;
          console.log("üé¨ Found 'open' animation:", targetClip.name);
        }
      }
      
      window.animationClip = targetClip;
      
      // Get or create action for this clip
      if (!window.actions[targetClip.name]) {
        console.log(`üé¨ Creating action for: ${targetClip.name}`);
        const action = window.mixer.clipAction(targetClip);
        action.loop = THREE.LoopOnce;
        action.clampWhenFinished = true;
        window.actions[targetClip.name] = action;
      }
      
      window.currentAction = window.actions[targetClip.name];
      
      console.log("üé¨ Current action:", window.currentAction);
      
      if (window.currentAction) {
        try {
          // Reset and play animation
          window.mixer.stopAllAction();
          window.currentAction.reset().play();
          window.mixer.timeScale = 1; // Ensure normal speed
          
          // Lock camera during animation
          isAnimationPlaying = true;
          controls.enableRotate = false;
          controls.enablePan = false;
          controls.enableZoom = false;
          
          // Update UI
          const dropdown = document.getElementById("animation-dropdown");
          if (dropdown) dropdown.value = targetClip.name;
          
          const durationEl = document.getElementById("anim-duration");
          if (durationEl) durationEl.textContent = targetClip.duration.toFixed(2);
          
          const infoEl = document.getElementById("anim-info");
          if (infoEl) infoEl.textContent = `${targetClip.name} - ${targetClip.duration.toFixed(2)}s [Interactive]`;
          
          const timelineEl = document.getElementById("anim-timeline");
          if (timelineEl) {
            timelineEl.max = 10000;
            timelineEl.value = 0;
          }
          
          console.log("‚ñ∂ Playing interactive animation:", targetClip.name, "Duration:", targetClip.duration, "s");
        } catch (err) {
          console.error("Error playing animation:", err);
        }
      } else {
        console.error("‚ùå Action not found for:", targetClip.name);
      }
    } else {
      console.warn("‚ö†Ô∏è No animations available to play");
      console.warn("   animationsArray:", window.animationsArray);
    }
  }
  
  // ===== SIMPLE PHYSICS FOR CARD =====
  let cardPhysics = {
    velocity: new THREE.Vector3(0, 0, 0),
    angularVelocity: new THREE.Vector3(0, 0, 0),
    damping: 0.95,
    angularDamping: 0.92
  };
  
  function applyCardPhysics() {
    // Random impulse direction
    const impulseMagnitude = 0.3;
    cardPhysics.velocity.set(
      (Math.random() - 0.5) * impulseMagnitude,
      Math.random() * impulseMagnitude * 0.5,
      (Math.random() - 0.5) * impulseMagnitude
    );
    
    // Random rotation
    cardPhysics.angularVelocity.set(
      (Math.random() - 0.5) * 2,
      (Math.random() - 0.5) * 2,
      (Math.random() - 0.5) * 2
    );
  }
  
  function updateCardPhysics() {
    if (!root) return;
    
    // Don't apply physics during animations (prevents camera jitter)
    if (isAnimationPlaying) return;
    
    // Apply velocity
    root.position.add(cardPhysics.velocity);
    
    // Apply rotation
    const euler = new THREE.Euler(
      cardPhysics.angularVelocity.x * 0.02,
      cardPhysics.angularVelocity.y * 0.02,
      cardPhysics.angularVelocity.z * 0.02,
      'XYZ'
    );
    const quat = new THREE.Quaternion();
    quat.setFromEuler(euler);
    root.quaternion.multiplyQuaternions(quat, root.quaternion);
    
    // Apply damping
    cardPhysics.velocity.multiplyScalar(cardPhysics.damping);
    cardPhysics.angularVelocity.multiplyScalar(cardPhysics.angularDamping);
    
    // Stop if velocity is negligible
    if (cardPhysics.velocity.lengthSq() < 0.0001) {
      cardPhysics.velocity.set(0, 0, 0);
    }
    if (cardPhysics.angularVelocity.lengthSq() < 0.0001) {
      cardPhysics.angularVelocity.set(0, 0, 0);
    }
  }
  
  // Find border meshes for collision
  function setupBorderCollision() {
    console.log('üîç Searching for collision border meshes...');
    
    // First try to find explicit cameraborder/border meshes
    scene.traverse((obj) => {
      // Check if this is a cameraborder group/parent or has it in the name
      if (obj.name.toLowerCase().includes('cameraborder') || obj.name.toLowerCase().includes('border')) {
        console.log('Found border object:', obj.name, '| isMesh:', obj.isMesh);
        
        if (obj.isMesh) {
          // Direct mesh
          borderMeshes.push(obj);
          const bbox = new THREE.Box3().setFromObject(obj);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          obj.userData.boundingBox = bbox;
          console.log(`  ‚úì Added as collision mesh: ${obj.name}`);
          console.log(`    Geometry: ${obj.geometry.getAttribute('position')?.count || 0} vertices, ${obj.geometry.index ? obj.geometry.index.count/3 : obj.geometry.getAttribute('position')?.count/3 || 0} triangles`);
        } else {
          // It's a group - get all mesh children
          obj.traverse((child) => {
            if (child.isMesh && child !== obj) {
              borderMeshes.push(child);
              const bbox = new THREE.Box3().setFromObject(child);
              const size = new THREE.Vector3();
              bbox.getSize(size);
              child.userData.boundingBox = bbox;
              console.log(`  ‚úì Added child mesh: ${child.name}`);
              console.log(`    Geometry: ${child.geometry.getAttribute('position')?.count || 0} vertices, ${child.geometry.index ? child.geometry.index.count/3 : child.geometry.getAttribute('position')?.count/3 || 0} triangles`);
            }
          });
        }
      }
    });
    
    if (borderMeshes.length > 0) {
      cameraCollisionEnabled = true;
      console.log(`‚úì Found ${borderMeshes.length} collision mesh(es)`);
      return;
    }
    
    console.log('‚ö†Ô∏è No explicit border meshes found - analyzing scene...');
    
    // Fallback: use intelligent mesh selection for room bounds
    const meshAnalysis = [];
    let totalMeshSize = 0;
    
    root.traverse((obj) => {
      if (obj.isMesh) {
        const bbox = new THREE.Box3().setFromObject(obj);
        const size = new THREE.Vector3();
        bbox.getSize(size);
        const volume = size.x * size.y * size.z;
        
        meshAnalysis.push({
          name: obj.name,
          bbox: bbox,
          size: size,
          volume: volume,
          obj: obj
        });
        totalMeshSize += volume;
      }
    });
    
    // Sort by volume to find the largest mesh (likely the room)
    meshAnalysis.sort((a, b) => b.volume - a.volume);
    
    // Use largest mesh as room boundary, but exclude very small objects (likely props/decorations)
    const largestMeshes = meshAnalysis.filter(m => m.volume > totalMeshSize * 0.01); // At least 1% of total
    
    let meshBounds;
    if (largestMeshes.length > 0) {
      meshBounds = new THREE.Box3();
      largestMeshes.forEach(m => {
        meshBounds.union(m.bbox);
      });
      
      console.log(`üì¶ Identified ${largestMeshes.length} large mesh(es) as room boundary`);
      largestMeshes.slice(0, 5).forEach(m => {
        console.log(`  ‚îî‚îÄ ${m.name} (${(m.volume).toFixed(3)} units¬≥)`);
      });
    } else {
      // Fallback to all meshes
      meshBounds = new THREE.Box3();
      meshAnalysis.forEach(m => {
        meshBounds.union(m.bbox);
      });
      console.log(`üì¶ Using all ${meshAnalysis.length} meshes for boundary`);
    }
    
    const sceneSize = new THREE.Vector3();
    meshBounds.getSize(sceneSize);
    
    console.log(`üì¶ Smart Room Bounds:`);
    console.log(`  Min: (${meshBounds.min.x.toFixed(3)}, ${meshBounds.min.y.toFixed(3)}, ${meshBounds.min.z.toFixed(3)})`);
    console.log(`  Max: (${meshBounds.max.x.toFixed(3)}, ${meshBounds.max.y.toFixed(3)}, ${meshBounds.max.z.toFixed(3)})`);
    console.log(`  Size: X=${sceneSize.x.toFixed(3)} Y=${sceneSize.y.toFixed(3)} Z=${sceneSize.z.toFixed(3)}`);
    
    // Expand bounds slightly to be safe
    const padding = 0.05;
    meshBounds.min.addScalar(-padding);
    meshBounds.max.addScalar(padding);
    
    // Create a proxy collision object with scene bounds
    const sceneCollisionProxy = {
      userData: {
        boundingBox: meshBounds.clone()
      }
    };
    borderMeshes.push(sceneCollisionProxy);
    cameraCollisionEnabled = true;
    
    console.log(`‚úì Smart collision boundary enabled with 0.05 unit buffer`);
  }
  
  // Visualization helpers for collision bounds
  let collisionVisualsGroup = null;
  
  function toggleCollisionVisualization() {
    if (!collisionVisualsGroup) {
      createCollisionVisuals();
    }
    
    const isVisible = collisionVisualsGroup.visible;
    collisionVisualsGroup.visible = !isVisible;
    console.log(`${!isVisible ? 'üëÅÔ∏è Showing' : 'üëÅÔ∏è Hiding'} collision bounds visualization`);
  }
  
  function createCollisionVisuals() {
    collisionVisualsGroup = new THREE.Group();
    collisionVisualsGroup.name = 'CollisionVisuals';
    scene.add(collisionVisualsGroup);
    
    const COLLISION_RADIUS = 0.08;
    
    for (let borderMesh of borderMeshes) {
      const bbox = borderMesh.userData.boundingBox;
      if (!bbox) continue;
      
      // Create wireframe box showing collision bounds
      const size = new THREE.Vector3();
      bbox.getSize(size);
      const center = new THREE.Vector3();
      bbox.getCenter(center);
      
      // Create outer boundary box (full bounds)
      const outerGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
      const outerMat = new THREE.LineBasicMaterial({ 
        color: 0x00ff00, 
        linewidth: 2,
        transparent: true,
        opacity: 0.6
      });
      const outerBox = new THREE.LineSegments(
        new THREE.EdgesGeometry(outerGeo),
        outerMat
      );
      outerBox.position.copy(center);
      outerBox.name = 'CollisionBoundaryOuter';
      collisionVisualsGroup.add(outerBox);
      
      // Create inner boundary box (with collision buffer)
      const innerSize = size.clone().addScalar(-COLLISION_RADIUS * 2);
      const innerGeo = new THREE.BoxGeometry(
        Math.max(0.1, innerSize.x), 
        Math.max(0.1, innerSize.y), 
        Math.max(0.1, innerSize.z)
      );
      const innerMat = new THREE.LineBasicMaterial({ 
        color: 0xffff00, 
        linewidth: 2,
        transparent: true,
        opacity: 0.8
      });
      const innerBox = new THREE.LineSegments(
        new THREE.EdgesGeometry(innerGeo),
        innerMat
      );
      innerBox.position.copy(center);
      innerBox.name = 'CollisionBoundarySafe';
      collisionVisualsGroup.add(innerBox);
      
      // Collision planes disabled to prevent z-fighting artifacts
      // Wireframe boxes above provide sufficient visualization
    }
  }
  
  // Helper function to calculate distance from point to triangle
  function pointToTriangleDistance(point, v0, v1, v2) {
    // Calculate vectors
    const edge0 = v1.clone().sub(v0);
    const edge1 = v2.clone().sub(v0);
    const toPoint = point.clone().sub(v0);
    
    // Project point onto triangle plane
    const a = edge0.dot(edge0);
    const b = edge0.dot(edge1);
    const c = edge1.dot(edge1);
    const d = edge0.dot(toPoint);
    const e = edge1.dot(toPoint);
    
    const denom = a * c - b * b;
    let u = d * c - b * e;
    let v = a * e - b * d;
    
    let distance;
    
    if (denom < 0.00001) {
      // Triangle is degenerate
      distance = point.distanceTo(v0);
    } else if (u < 0) {
      if (v < 0) {
        // Closest to v0
        distance = point.distanceTo(v0);
      } else if (v > denom) {
        // Closest to v2
        distance = point.distanceTo(v2);
      } else {
        // Closest to edge v0-v2
        const closest = v0.clone().add(edge1.multiplyScalar(v / denom));
        distance = point.distanceTo(closest);
      }
    } else if (u > denom) {
      if (v < 0) {
        // Closest to v1
        distance = point.distanceTo(v1);
      } else if (v > denom) {
        // Closest to v2
        distance = point.distanceTo(v2);
      } else {
        // Closest to edge v1-v2
        const edge = v2.clone().sub(v1);
        const toV1 = point.clone().sub(v1);
        const t = Math.max(0, Math.min(1, toV1.dot(edge) / edge.lengthSq()));
        const closest = v1.clone().add(edge.multiplyScalar(t));
        distance = point.distanceTo(closest);
      }
    } else if (v < 0) {
      // Closest to edge v0-v1
      const closest = v0.clone().add(edge0.multiplyScalar(u / denom));
      distance = point.distanceTo(closest);
    } else if (v > denom) {
      // Closest to edge v1-v2
      const edge = v2.clone().sub(v1);
      const toV1 = point.clone().sub(v1);
      const t = Math.max(0, Math.min(1, toV1.dot(edge) / edge.lengthSq()));
      const closest = v1.clone().add(edge.multiplyScalar(t));
      distance = point.distanceTo(closest);
    } else {
      // Inside triangle, distance is 0 (point projects onto triangle face)
      const normal = edge0.clone().cross(edge1).normalize();
      const toFace = toPoint.clone().sub(normal.clone().multiplyScalar(toPoint.dot(normal)));
      distance = Math.abs(point.clone().sub(v0.clone().add(toFace)).length());
    }
    
    return distance;
  }
  
  // Helper function to calculate closest distance to mesh
  function getClosestDistanceToMesh(point, mesh) {
    let minDistance = Infinity;
    
    // Only process if mesh has geometry
    if (!mesh.geometry) return minDistance;
    
    const geometry = mesh.geometry;
    const positionAttribute = geometry.getAttribute('position');
    
    if (!positionAttribute) return minDistance;
    
    // Get vertex positions
    const vertices = [];
    for (let i = 0; i < positionAttribute.count; i++) {
      const vertex = new THREE.Vector3();
      vertex.fromBufferAttribute(positionAttribute, i);
      // Apply mesh's world transformation
      vertex.applyMatrix4(mesh.matrixWorld);
      vertices.push(vertex);
    }
    
    // Check against triangles (indices or non-indexed)
    if (geometry.index) {
      const indices = geometry.index.array;
      for (let i = 0; i < indices.length; i += 3) {
        const v0 = vertices[indices[i]];
        const v1 = vertices[indices[i + 1]];
        const v2 = vertices[indices[i + 2]];
        
        const dist = pointToTriangleDistance(point, v0, v1, v2);
        minDistance = Math.min(minDistance, dist);
      }
    } else {
      // Non-indexed geometry
      for (let i = 0; i < vertices.length; i += 3) {
        const v0 = vertices[i];
        const v1 = vertices[i + 1];
        const v2 = vertices[i + 2];
        
        const dist = pointToTriangleDistance(point, v0, v1, v2);
        minDistance = Math.min(minDistance, dist);
      }
    }
    
    return minDistance;
  }
  
  // Simple point-to-triangle collision - returns closest point and distance
  function getClosestPointOnTriangle(point, v0, v1, v2) {
    const edge0 = v1.clone().sub(v0);
    const edge1 = v2.clone().sub(v0);
    const toPoint = point.clone().sub(v0);
    
    const a = edge0.dot(edge0);
    const b = edge0.dot(edge1);
    const c = edge1.dot(edge1);
    const d = edge0.dot(toPoint);
    const e = edge1.dot(toPoint);
    
    const denom = a * c - b * b;
    let u = 0, v = 0;
    
    if (Math.abs(denom) > 0.0001) {
      u = (d * c - b * e) / denom;
      v = (a * e - b * d) / denom;
    }
    
    // Clamp to triangle
    if (u < 0) u = 0;
    if (v < 0) v = 0;
    if (u + v > 1) {
      const t = 1 - (u + v);
      u = Math.max(0, u + t * 0.5);
      v = Math.max(0, v + t * 0.5);
    }
    
    const closestPt = v0.clone().add(edge0.clone().multiplyScalar(u)).add(edge1.clone().multiplyScalar(v));
    const distance = point.distanceTo(closestPt);
    
    return { point: closestPt, distance: distance };
  }
  
  // Check sphere collision - simple and reliable
  function checkSphereCollisionWithMesh(sphereCenter, sphereRadius, mesh) {
    if (!mesh.geometry) return { colliding: false, penetration: 0, closestPoint: sphereCenter.clone() };
    
    const geometry = mesh.geometry;
    const positionAttribute = geometry.getAttribute('position');
    if (!positionAttribute) return { colliding: false, penetration: 0, closestPoint: sphereCenter.clone() };
    
    // Get all vertices
    const vertices = [];
    for (let i = 0; i < positionAttribute.count; i++) {
      const vertex = new THREE.Vector3();
      vertex.fromBufferAttribute(positionAttribute, i);
      vertex.applyMatrix4(mesh.matrixWorld);
      vertices.push(vertex);
    }
    
    let minDistance = Infinity;
    let closestPoint = sphereCenter.clone();
    
    // Check all triangles
    if (geometry.index) {
      const indices = geometry.index.array;
      for (let i = 0; i < indices.length; i += 3) {
        const v0 = vertices[indices[i]];
        const v1 = vertices[indices[i + 1]];
        const v2 = vertices[indices[i + 2]];
        
        const result = getClosestPointOnTriangle(sphereCenter, v0, v1, v2);
        if (result.distance < minDistance) {
          minDistance = result.distance;
          closestPoint = result.point;
        }
      }
    } else {
      for (let i = 0; i < vertices.length; i += 3) {
        const v0 = vertices[i];
        const v1 = vertices[i + 1];
        const v2 = vertices[i + 2];
        
        const result = getClosestPointOnTriangle(sphereCenter, v0, v1, v2);
        if (result.distance < minDistance) {
          minDistance = result.distance;
          closestPoint = result.point;
        }
      }
    }
    
    const penetration = sphereRadius - minDistance;
    const colliding = penetration > 0;
    
    // Push direction is from closest point away from center
    let pushDir = new THREE.Vector3(0, 0, 1);
    if (minDistance > 0.0001) {
      pushDir = sphereCenter.clone().sub(closestPoint).normalize();
    }
    
    return { 
      colliding, 
      penetration: Math.max(0, penetration), 
      closestPoint: closestPoint,
      pushDirection: pushDir,
      distance: minDistance
    };
  }
  
  // Helper: Get closest point on box to a sphere center (handles corners!)
  function getClosestPointOnBox(point, boxMin, boxMax) {
    const closest = new THREE.Vector3();
    closest.x = Math.max(boxMin.x, Math.min(point.x, boxMax.x));
    closest.y = Math.max(boxMin.y, Math.min(point.y, boxMax.y));
    closest.z = Math.max(boxMin.z, Math.min(point.z, boxMax.z));
    return closest;
  }
  
  // Bulletproof bounding box collision with corner detection - keep camera INSIDE the mesh bounds with no slips
  function checkCameraCollision() {
    if (window.skipCollisionCheck || !cameraCollisionEnabled || borderMeshes.length === 0) return;
    
    const camPos = camera.position;
    const radius = collisionRadius;
    const EPSILON = 0.0001; // Floating-point safety margin
    
    // Cache combined bounds to avoid recomputing every frame
    if (!window.collisionBoundsCache || window.collisionBoundsDirty) {
      let combinedBox = new THREE.Box3();
      
      for (let borderMesh of borderMeshes) {
        // Get bounding box
        let bbox;
        if (borderMesh.userData?.boundingBox) {
          bbox = borderMesh.userData.boundingBox.clone();
        } else if (borderMesh.geometry) {
          bbox = new THREE.Box3().setFromObject(borderMesh);
          borderMesh.userData = borderMesh.userData || {};
          borderMesh.userData.boundingBox = bbox.clone();
        } else {
          continue;
        }
        
        // Expand combined box to include all meshes
        combinedBox.union(bbox);
      }
      
      // Cache the bounds
      window.collisionBoundsCache = combinedBox.clone();
      window.collisionBoundsDirty = false;
      
      // Debug: log bounds on first collision check
      if (!window.collisionBoundsLogged) {
        const minBound = combinedBox.min.clone().addScalar(radius);
        const maxBound = combinedBox.max.clone().addScalar(-radius);
        console.log(`üì¶ Combined collision bounds:`);
        console.log(`  Raw Box: Min (${combinedBox.min.x.toFixed(3)}, ${combinedBox.min.y.toFixed(3)}, ${combinedBox.min.z.toFixed(3)}) Max (${combinedBox.max.x.toFixed(3)}, ${combinedBox.max.y.toFixed(3)}, ${combinedBox.max.z.toFixed(3)})`);
        console.log(`  Safe Zone (radius=${radius.toFixed(3)}): Min (${minBound.x.toFixed(3)}, ${minBound.y.toFixed(3)}, ${minBound.z.toFixed(3)}) Max (${maxBound.x.toFixed(3)}, ${maxBound.y.toFixed(3)}, ${maxBound.z.toFixed(3)})`);
        window.collisionBoundsLogged = true;
      }
    }
    
    const combinedBox = window.collisionBoundsCache;
    
    // Create safe inner bounds (strict clamping zone)
    const minBound = new THREE.Vector3(
      combinedBox.min.x + radius + EPSILON,
      combinedBox.min.y + radius + EPSILON,
      combinedBox.min.z + radius + EPSILON
    );
    
    const maxBound = new THREE.Vector3(
      combinedBox.max.x - radius - EPSILON,
      combinedBox.max.y - radius - EPSILON,
      combinedBox.max.z - radius - EPSILON
    );
    
    // ===== SPHERE-BASED CORNER COLLISION (handles diagonals) =====
    // Get closest point on the inner box to the camera
    const closestPoint = getClosestPointOnBox(camPos, minBound, maxBound);
    const distanceToBox = camPos.distanceTo(closestPoint);
    
    let newPos = camPos.clone();
    let collided = false;
    
    // If camera is outside the box (near corners or edges), push it back
    if (distanceToBox > EPSILON) {
      const pushDirection = camPos.clone().sub(closestPoint).normalize();
      const pushDistance = distanceToBox + EPSILON;
      newPos = closestPoint.clone().sub(pushDirection.multiplyScalar(pushDistance));
      collided = true;
    } else {
      // Camera is inside box, just do standard axis clamping as fallback
      // Strong axis-aligned boundary enforcement
      if (newPos.x <= minBound.x) {
        newPos.x = minBound.x;
        collided = true;
      } else if (newPos.x >= maxBound.x) {
        newPos.x = maxBound.x;
        collided = true;
      }
      
      if (newPos.y <= minBound.y) {
        newPos.y = minBound.y;
        collided = true;
      } else if (newPos.y >= maxBound.y) {
        newPos.y = maxBound.y;
        collided = true;
      }
      
      if (newPos.z <= minBound.z) {
        newPos.z = minBound.z;
        collided = true;
      } else if (newPos.z >= maxBound.z) {
        newPos.z = maxBound.z;
        collided = true;
      }
    }
    
    // Apply corrected position immediately (no smoothing to ensure perfect collision)
    if (collided) {
      camera.position.copy(newPos);
      // Also update controls target to prevent slipping during orbit
      const offset = controls.target.clone().sub(camPos);
      controls.target.copy(newPos.clone().add(offset));
    }
    
    // Log collision events for debugging
    if (!window.collisionState) {
      window.collisionState = { colliding: false, lastPos: camPos.clone() };
    }
    
    if (collided && !window.collisionState.colliding) {
      console.log(`‚ö†Ô∏è COLLISION: Camera hit boundary at (${newPos.x.toFixed(2)}, ${newPos.y.toFixed(2)}, ${newPos.z.toFixed(2)})`);
      window.collisionState.colliding = true;
    } else if (!collided && window.collisionState.colliding) {
      console.log(`‚úì Collision cleared`);
      window.collisionState.colliding = false;
    }
    
    window.collisionState.lastPos = camPos.clone();
  }
  
  // Setup border collision and extract bones after model loads
  function initializeBorderCollision() {
    if (root) {
      setupBorderCollision();
      extractAndVisualizeBones();
    }
  }
  
  renderer.domElement.addEventListener('mousedown', (event) => {
    // Don't interact if clicking on UI elements
    if (event.target !== renderer.domElement) return;
    
    // Calculate mouse position in normalized device coordinates
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    // Update the picking ray with the camera and mouse position
    raycaster.setFromCamera(mouse, camera);
    
    // ===== CHECK BONE INTERSECTION FIRST =====
    let clickedBone = null;
    const boneHelperObjects = Object.values(boneHelpers);
    console.log("ü¶¥ Checking bone intersection. Available bones:", Object.keys(boneHelpers).length);
    const boneIntersects = raycaster.intersectObjects(boneHelperObjects);
    
    if (boneIntersects.length > 0) {
      const clickedBoneHelper = boneIntersects[0].object;
      clickedBone = clickedBoneHelper.userData.boneName;
      selectedBone = clickedBone;
      
      console.log("ü¶¥ BONE CLICKED:", clickedBone);
      
      // Highlight selected bone
      clickedBoneHelper.material.emissive.setHex(0xffff00);
      clickedBoneHelper.material.emissiveIntensity = 1.0;
      clickedBoneHelper.material.opacity = 1.0;
      
      // Check if this is the freeplay bone
      if (clickedBone === freeplayBone) {
        // Freeplay mode: enable free physics interaction
        isDraggingMesh = true;
        draggedObject = root;
        
        // Calculate drag plane
        const cameraDirection = camera.getWorldDirection(new THREE.Vector3());
        dragPlane.setFromNormalAndCoplanarPoint(cameraDirection, draggedObject.position);
        
        // Get the click point on the bone helper
        const dragStartPos = clickedBoneHelper.position.clone();
        dragOffsetFromCenter.copy(draggedObject.position).sub(dragStartPos);
        
        renderer.domElement.style.cursor = 'grabbing';
        console.log("üéÆ FREEPLAY MODE ACTIVATED - Drag to move freely!");
      } else {
        // Regular bone: trigger animation
        console.log("ü¶¥ Regular bone clicked, triggering animation...");
        triggerCardAnimation();
        console.log("ü¶¥ Bone clicked:", clickedBone);
      }
      return;
    } else {
      console.log("ü¶¥ No bones clicked, checking meshes...");
    }
    
    // ===== THEN CHECK MESH INTERSECTION =====
    // Get all meshes from the loaded model
    const meshes = [];
    if (root) {
      root.traverse((obj) => {
        if (obj.isMesh) meshes.push(obj);
      });
    }
    
    // Calculate objects intersecting the picking ray
    const intersects = raycaster.intersectObjects(meshes);
    
    if (intersects.length > 0) {
      const clickedPoint = intersects[0].point;
      const clickedObject = intersects[0].object;
      const objectName = clickedObject.name.toLowerCase();
      
      // Check if this is a card/book object
      const isCardObject = objectName.includes('book') || objectName.includes('card') || objectName.includes('cover') || objectName.includes('page');
      
      if (isCardObject) {
        // Start dragging
        isDraggingMesh = true;
        draggedObject = root; // Drag the entire root model
        
        // Calculate drag plane (perpendicular to camera view)
        const cameraDirection = camera.getWorldDirection(new THREE.Vector3());
        dragPlane.setFromNormalAndCoplanarPoint(cameraDirection, draggedObject.position);
        
        // Calculate offset from object center to click point
        dragOffsetFromCenter.copy(draggedObject.position).sub(clickedPoint);
        
        // Trigger animation
        triggerCardAnimation();
        console.log("üé¥ Card interaction detected! Starting animation...");
      } else {
        // Just process click on other objects
        console.log("Clicked object:", clickedObject.name || "unnamed", clickedObject);
      }
      
      // Deselect previous object
      if (selectedObject && selectedMaterial) {
        selectedObject.material = selectedMaterial;
      }
      
      // Select new object
      selectedObject = clickedObject;
      selectedMaterial = selectedObject.material.clone();
      
      console.log("Clicked object:", selectedObject.name || "unnamed", selectedObject);
    } else {
      // Deselect
      if (selectedObject && selectedMaterial) {
        selectedObject.material = selectedMaterial;
        selectedObject = null;
        selectedMaterial = null;
        console.log("Deselected");
      }
    }
  });
  
  renderer.domElement.addEventListener('mousemove', (event) => {
    // Don't interact if clicking on UI elements
    if (event.target !== renderer.domElement) return;
    
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    // Handle dragging
    if (isDraggingMesh && draggedObject) {
      raycaster.setFromCamera(mouse, camera);
      raycaster.ray.intersectPlane(dragPlane, dragPointOnPlane);
      
      // Move the object to follow the mouse on the drag plane
      let newPosition = dragPointOnPlane.clone().add(dragOffsetFromCenter);
      
      // Snap to grid if enabled
      newPosition.x = Math.round(newPosition.x / GRID_SNAP) * GRID_SNAP;
      newPosition.y = Math.round(newPosition.y / GRID_SNAP) * GRID_SNAP;
      newPosition.z = Math.round(newPosition.z / GRID_SNAP) * GRID_SNAP;
      
      // Calculate drag velocity for bounce physics
      dragVelocity.copy(newPosition).sub(draggedObject.position);
      draggedObject.position.copy(newPosition);
      lastDragPosition.copy(newPosition);
      
      // Handle rotation with Shift key
      if (event.shiftKey) {
        // Rotate based on mouse movement
        const mouseMovementX = event.movementX || 0;
        const mouseMovementY = event.movementY || 0;
        
        // Apply rotation
        draggedObject.rotation.y += mouseMovementX * ROTATION_SENSITIVITY * 0.01;
        draggedObject.rotation.x += mouseMovementY * ROTATION_SENSITIVITY * 0.01;
        
        renderer.domElement.style.cursor = 'grabbing rotate';
      } else {
        renderer.domElement.style.cursor = 'grabbing';
      }
      return; // Don't check hover when dragging
    }
    
    // ===== BONE HOVER DETECTION =====
    raycaster.setFromCamera(mouse, camera);
    const boneHelperObjects = Object.values(boneHelpers);
    const boneHoverIntersects = raycaster.intersectObjects(boneHelperObjects);
    
    // Reset all bones to normal state
    for (let boneName in boneHelpers) {
      const helper = boneHelpers[boneName];
      
      // Keep freeplay bone special color when not hovering
      if (boneName === freeplayBone) {
        helper.material.emissive.setHex(0xff00ff);
        helper.material.emissiveIntensity = 0.8;
        helper.material.opacity = bonesVisible ? 0.9 : 0; // Show if bonesVisible toggle is on
      } else {
        helper.material.emissive.setHex(0x00aa44);
        helper.material.emissiveIntensity = 0.3;
        helper.material.opacity = bonesVisible ? 0.6 : 0; // Show if bonesVisible toggle is on
      }
    }
    
    if (boneHoverIntersects.length > 0) {
      // Bone hover detected but no visual effect
      const hoveredBoneHelper = boneHoverIntersects[0].object;
      const boneName = hoveredBoneHelper.userData.boneName;
      renderer.domElement.style.cursor = 'pointer';
      
      // Update dev console with bone info
      const boneObj = hoveredBoneHelper.userData.boneObject;
      const worldPos = boneObj.getWorldPosition(new THREE.Vector3());
      document.getElementById('hover-type').innerHTML = `Type: <span style="color: #88ff00;">BONE</span>`;
      document.getElementById('hover-name').innerHTML = `Name: <span style="color: #88ff00;">${boneName}</span>`;
      document.getElementById('hover-position').innerHTML = `Pos: <span style="color: #88ff00;">(${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)})</span>`;
      
      return; // Don't check mesh hover if hovering bone
    }
    
    // ===== MESH HOVER DETECTION =====
    raycaster.setFromCamera(mouse, camera);
    
    const meshes = [];
    if (root) {
      root.traverse((obj) => {
        if (obj.isMesh) meshes.push(obj);
      });
    }
    
    const intersects = raycaster.intersectObjects(meshes);
    
    if (intersects.length > 0) {
      const hoveredMesh = intersects[0].object;
      const meshName = hoveredMesh.name.toLowerCase();
      const isCardObject = meshName.includes('book') || meshName.includes('card') || meshName.includes('cover') || meshName.includes('page');
      
      // Update dev console with mesh info
      const meshWorldPos = hoveredMesh.getWorldPosition(new THREE.Vector3());
      document.getElementById('hover-type').innerHTML = `Type: <span style="color: #88ff00;">MESH</span>`;
      document.getElementById('hover-name').innerHTML = `Name: <span style="color: #88ff00;">${hoveredMesh.name}</span>`;
      document.getElementById('hover-position').innerHTML = `Pos: <span style="color: #88ff00;">(${meshWorldPos.x.toFixed(2)}, ${meshWorldPos.y.toFixed(2)}, ${meshWorldPos.z.toFixed(2)})</span>`;
      
      if (isCardObject && hoveredMesh !== previousHoveredObject) {
        // Just entered card object
        previousHoveredObject = hoveredMesh;
        hoveredObject = hoveredMesh;
        renderer.domElement.style.cursor = 'grab';
      } else if (!isCardObject && previousHoveredObject) {
        // Left card object
        previousHoveredObject = null;
        hoveredObject = null;
        renderer.domElement.style.cursor = 'default';
      }
    } else {
      // No objects hovered
      if (previousHoveredObject) {
        previousHoveredObject = null;
        hoveredObject = null;
        renderer.domElement.style.cursor = 'default';
        
        // Clear hover info
        document.getElementById('hover-type').innerHTML = `Type: <span style="color: #88ff00;">‚Äî</span>`;
        document.getElementById('hover-name').innerHTML = `Name: <span style="color: #88ff00;">‚Äî</span>`;
        document.getElementById('hover-position').innerHTML = `Pos: <span style="color: #88ff00;">‚Äî</span>`;
      }
    }
  });
  
  renderer.domElement.addEventListener('mouseup', (event) => {
    if (isDraggingMesh) {
      isDraggingMesh = false;
      draggedObject = null;
      renderer.domElement.style.cursor = hoveredObject ? 'grab' : 'default';
      
      // Apply bounce physics from drag velocity
      if (dragVelocity.lengthSq() > 0.001) {
        cardPhysics.velocity.copy(dragVelocity).multiplyScalar(2.5); // Amplify for bouncy feel
        cardPhysics.angularVelocity.set(
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3
        );
        console.log("üí® Bounce physics applied!");
      }
      
      dragVelocity.set(0, 0, 0);
      
      // Check if freeplay mode was active
      if (selectedBone === freeplayBone) {
        document.getElementById('freeplay-mode-indicator').style.display = 'block';
        console.log("‚úì Freeplay drag finished - Physics continuing");
      } else {
        document.getElementById('freeplay-mode-indicator').style.display = 'none';
        console.log("‚úì Drag finished");
      }
    }
  });
  
  addEventListener("resize",()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });
  
  let lastFrameTime = performance.now();
  
  // Setup efficient frustum culling
  const frustum = new THREE.Frustum();
  const projScreenMatrix = new THREE.Matrix4();
  
  function updateFrustumCulling() {
    // Update projection matrix and calculate frustum
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);
  }
  
  // Count visible objects in frustum
  function countVisibleObjects() {
    let visibleCount = 0;
    let totalTriangles = 0;
    let drawcalls = 0;
    
    scene.traverse(obj => {
      if (obj.isMesh && obj.visible) {
        // Check if object is in frustum
        if (obj.geometry && frustum.intersectsBox(new THREE.Box3().setFromObject(obj))) {
          visibleCount++;
          drawcalls++;
          
          // Count triangles
          if (obj.geometry.index) {
            totalTriangles += obj.geometry.index.count / 3;
          } else if (obj.geometry.attributes.position) {
            totalTriangles += obj.geometry.attributes.position.count / 3;
          }
        }
      }
    });
    
    // Update UI
    if (document.getElementById('dev-visible-objects')) {
      document.getElementById('dev-visible-objects').textContent = visibleCount;
    }
    if (document.getElementById('dev-triangles')) {
      document.getElementById('dev-triangles').textContent = Math.round(totalTriangles);
    }
    if (document.getElementById('dev-drawcalls')) {
      document.getElementById('dev-drawcalls').textContent = drawcalls;
    }
  }
  
  // ============================================================================
  // VISUAL FILTERS SYSTEM
  // ============================================================================
  
  let currentFilter = 'none';
  
  // Initialize filter system
  function initializeFilters() {
    console.log('‚úì Visual filters initialized: PS2, VHS');
  }
  
  // Apply filter to scene using canvas CSS filters
  function applyFilter(filterType) {
    const canvas = renderer.domElement;
    currentFilter = filterType;
    document.getElementById('filter-active').textContent = filterType.toUpperCase();
    
    if (filterType === 'ps2') {
      // PS2 effect: posterize with scan lines
      canvas.style.filter = 'contrast(1.1) saturate(0.9)';
      canvas.style.imageRendering = 'pixelated';
      canvas.style.backgroundColor = '#0b0c10';
      
      // Add CSS to create scan line effect
      if (!document.getElementById('ps2-filter-style')) {
        const style = document.createElement('style');
        style.id = 'ps2-filter-style';
        style.textContent = `
          #canvas {
            background-image: 
              repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.08),
                rgba(0, 0, 0, 0.08) 1px,
                transparent 1px,
                transparent 2px
              );
            background-position: 0 0;
            background-size: 100% 2px;
          }
        `;
        document.head.appendChild(style);
      }
      console.log('‚úì PS2 Graphics filter enabled');
    } else if (filterType === 'vhs') {
      // VHS effect: glitch and grain
      canvas.style.filter = 'contrast(1.05) saturate(1.1) hue-rotate(2deg)';
      canvas.style.imageRendering = 'auto';
      canvas.style.backgroundColor = '#0b0c10';
      
      // Add VHS glitch effect
      if (!document.getElementById('vhs-filter-style')) {
        const style = document.createElement('style');
        style.id = 'vhs-filter-style';
        style.textContent = `
          @keyframes vhsGlitch {
            0% { text-shadow: 0 0 #ff00de, 2px 2px #00ffff; }
            20% { text-shadow: 0 0 #ff00de, -2px -2px #00ffff; }
            40% { text-shadow: 0 0 #ff00de, 2px -2px #00ffff; }
            60% { text-shadow: 0 0 #ff00de, -2px 2px #00ffff; }
            80% { text-shadow: 0 0 #ff00de, 0 0 #00ffff; }
          }
          
          #canvas {
            background-image: 
              repeating-linear-gradient(
                0deg,
                rgba(255, 0, 222, 0.03),
                rgba(255, 0, 222, 0.03) 1px,
                transparent 1px,
                transparent 2px
              );
            background-position: 0 0;
            background-size: 100% 4px;
          }
        `;
        document.head.appendChild(style);
      }
      console.log('‚úì VHS Effect filter enabled');
    } else {
      // Normal rendering
      canvas.style.filter = 'none';
      canvas.style.imageRendering = 'auto';
      console.log('‚úì Normal rendering');
    }
  }
  
  // Update filter (placeholder for consistency)
  function updateFilters() {
    // CSS filters update automatically
  }
  
  function animate() {
    requestAnimationFrame(animate);
    if (!window.animateStarted) {
      console.log("[ANIMATE STARTED] Rendering loop is running!");
      window.animateStarted = true;
    }
    
    // Update frustum for culling
    updateFrustumCulling();
    
    // Calculate delta time for frame-rate-independent updates
    const currentFrameTime = performance.now();
    const deltaTime = Math.min((currentFrameTime - lastFrameTime) / 1000, 0.1); // Cap at 100ms to prevent big jumps
    lastFrameTime = currentFrameTime;
    
    // Update controls FIRST so we catch any movement
    controls.update();
    
    // Optimize collision checking - only run every 2 frames to save performance
    if (!window.collisionCheckSkip) window.collisionCheckSkip = 0;
    if (window.collisionCheckSkip === 0) {
      checkCameraCollision();
    }
    window.collisionCheckSkip = (window.collisionCheckSkip + 1) % 2;
    
    // FPS monitoring
    frameCount++;
    const currentTime = performance.now();
    if (currentTime >= lastTime + 1000) {
      fps = frameCount;
      document.getElementById("fps").textContent = fps;
      
      // Memory monitoring (if available)
      if (performance.memory) {
        const memMB = (performance.memory.usedJSHeapSize / 1048576).toFixed(0);
        document.getElementById("memory").textContent = memMB;
      }
      
      // Count visible objects for optimization stats
      countVisibleObjects();
      
      frameCount = 0;
      lastTime = currentTime;
    }
    
    // Update bone visual positions
    updateBoneVisuals();
    
    // Update card physics simulation
    updateCardPhysics();

    // COLLISION CHECK: Only verify after user interaction or significant movement
    // (Already checked every 2 frames above, no need for redundant check here)
    
    // Update animation mixer if it exists
    if (window.mixer) {
      // Use frame time for accurate animation progression
      window.mixer.update(deltaTime);
      
      // ===== LOCK CAMERA TO ANIMATION IF AVAILABLE =====
      // If animation has camera tracks or model has camera bone, sync camera position
      if (isAnimationPlaying && window.cameraAnimationBone && window.currentAction) {
        updateCameraFromAnimationBone();
      }
      
      // Update timeline UI if animation is playing
      if (window.currentAction && window.animationClip) {
        // Clamp progress between 0 and 1 for accuracy
        const clampedTime = Math.max(0, Math.min(window.mixer.time, window.animationClip.duration));
        const progress = clampedTime / window.animationClip.duration;
        
        // Update timeline with high precision (0.01s increments)
        document.getElementById("anim-timeline").value = Math.round(progress * 10000) / 100;
        document.getElementById("anim-time").textContent = clampedTime.toFixed(2);
        
        // Handle animation chaining with smooth transition
        if (window.sequenceMode && progress >= 0.98 && !window.transitionedThisClip && window.animationsArray) {
          window.transitionedThisClip = true; // Prevent spam
          
          // Animation finished, play next in sequence
          const currentName = window.animationClip.name;
          const currentIdx = window.animationNames.indexOf(currentName);
          const nextIdx = (currentIdx + 1) % window.animationNames.length;
          const nextName = window.animationNames[nextIdx];
          
          if (nextName !== currentName) {
            console.log("Transitioning to next animation:", nextName);
            const nextClip = window.animationsArray.find(a => a.name === nextName);
            window.animationClip = nextClip;
            window.currentAction = window.actions[nextName];
            
            // Smooth crossfade transition (0.3 seconds)
            const previousAction = window.mixer.existingAction(window.currentAction.getClip());
            if (previousAction) {
              previousAction.fadeOut(0.3);
            }
            window.currentAction.reset().fadeIn(0.3).play();
            
            // Reset flag for next clip
            window.transitionedThisClip = false;
            
            // Update UI
            document.getElementById("anim-duration").textContent = nextClip.duration.toFixed(2);
            document.getElementById("anim-info").textContent = `${nextName} - ${nextClip.duration.toFixed(2)}s`;
            document.getElementById("anim-timeline").max = 10000; // 0-100 with 0.01 precision
            document.getElementById("anim-timeline").value = 0;
            document.getElementById("anim-time").textContent = "0.00";
            
            console.log(`‚úì Chained to: ${nextName}`);
          }
        }
        
        // Unlock camera when animation finishes (if not looping and not chaining)
        if (isAnimationPlaying && progress >= 1 && window.currentAction && !window.sequenceMode && window.currentAction.loop === THREE.LoopOnce) {
          isAnimationPlaying = false;
          controls.enableRotate = true;
          controls.enablePan = true;
          controls.enableZoom = true;
          controls.enabled = true; // Re-enable orbit controls
          // Reset physics
          cardPhysics.velocity.set(0, 0, 0);
          cardPhysics.angularVelocity.set(0, 0, 0);
          console.log("‚úì Camera controls unlocked - animation finished");
        }
      }
    }
    
    // Update debug menu display
    updateDebugMenu();
    
    // FINAL COLLISION CHECK: Ensure camera is in safe bounds right before rendering
    // This is our last safety net to catch any slips from other updates
    if (cameraCollisionEnabled) {
      checkCameraCollision();
    }
    
    // Frustum culling handled automatically by Three.js - manual culling disabled to prevent artifacts
    
    if (window.debugFrameCount === undefined) window.debugFrameCount = 0;
    if (window.debugFrameCount++ < 5 || window.debugFrameCount % 300 === 0) {
      console.log("[FRAME", window.debugFrameCount + "] Scene children:", scene.children.length, "Camera:", camera.position, "Target:", controls.target);
    }
    
    // Update visual filters
    updateFilters();
    
    renderer.render(scene,camera);
  }
  animate();
  
} catch(err) {
  console.error("Script error:", err);
  statusEl.textContent = "ERROR: " + err.message;
}

// ===== WINDOW DRAG FUNCTIONALITY =====
let isDragging = false;
let dragOffsetX = 0;
let dragOffsetY = 0;

function startDragWindow(event) {
  // Don't drag if clicking the close button
  if (event.target.textContent === '√ó') return;
  
  isDragging = true;
  const messageWindow = document.getElementById('message-window');
  const rect = messageWindow.getBoundingClientRect();
  
  dragOffsetX = event.clientX - rect.left;
  dragOffsetY = event.clientY - rect.top;
  
  document.addEventListener('mousemove', dragWindow);
  document.addEventListener('mouseup', stopDragWindow);
}

function dragWindow(event) {
  if (!isDragging) return;
  
  const messageWindow = document.getElementById('message-window');
  const mainMenu = document.getElementById('main-menu');
  const menuRect = mainMenu.getBoundingClientRect();
  
  let newX = event.clientX - dragOffsetX;
  let newY = event.clientY - dragOffsetY;
  
  // Clamp position within bounds
  newX = Math.max(0, Math.min(newX, menuRect.width - 520));
  newY = Math.max(0, Math.min(newY, menuRect.height - 100));
  
  messageWindow.style.left = newX + 'px';
  messageWindow.style.top = newY + 'px';
}

function stopDragWindow() {
  isDragging = false;
  document.removeEventListener('mousemove', dragWindow);
  document.removeEventListener('mouseup', stopDragWindow);
}
</script>
</body>
</html>



